{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bump2version NOTE This is a maintained fork of the excellent bumpversion project . Overview Version-bump your software with a single command! A small command line tool to simplify releasing software by updating all version strings in your source code by the correct increment. Also creates commits and tags: version formats are highly configurable works without any VCS, but happily reads tag information from and writes commits and tags to Git and Mercurial if available just handles text files, so it's not specific to any programming language supports Python 3 and PyPy3 If you want to use Python 2, use pip>=9 and you'll get the last supported version, or pin bump2version<1 . Alternatives If bump2version does not fully suit your needs, you could take a look at other tools doing similar or related tasks: RELATED.md . Installation You can download and install the latest version of this software from the Python package index (PyPI) as follows: pip install --upgrade bump2version NOTE: pip install bumpversion now installs the latest bump2version! Changelog Please find the changelog here: CHANGELOG.md Usage NOTE: Throughout this document you can use bumpversion or bump2version interchangeably. There are two modes of operation: On the command line for single-file operation and using a configuration file ( bumpversion.cfg ) for more complex multi-file operations. bump2version [ options ] part [ file ] part required The part of the version to increase, e.g. minor . Valid values include those given in the --serialize / --parse option. Example bumping 0.5.1 to 0.6.0: bump2version --current-version 0.5.1 minor src/VERSION file [optional] default : none The file that will be modified. This file is added to the list of files specified in [bumpversion:file:\u2026] sections from the configuration file. If you want to rewrite only files specified on the command line, use --no-configured-files . Example bumping 1.1.9 to 2.0.0: bump2version --current-version 1.1.9 major setup.py Configuration file All options can optionally be specified in a config file called .bumpversion.cfg so that once you know how bump2version needs to be configured for one particular software package, you can run it without specifying options later. You should add that file to VCS so others can also bump versions. Options on the command line take precedence over those from the config file, which take precedence over those derived from the environment and then from the defaults. Example .bumpversion.cfg : [bumpversion] current_version = 0.2.9 commit = True tag = True [bumpversion:file:setup.py] If no .bumpversion.cfg exists, bump2version will also look into setup.cfg for configuration. Configuration file -- Global configuration General configuration is grouped in a [bumpversion] section. current_version required default : none The current version of the software package before bumping. Also available as --current-version (e.g. bump2version --current-version 0.5.1 patch setup.py ) new_version [optional] default : none The version of the software package after the increment. If not given will be automatically determined. Also available as --new-version (e.g. to go from 0.5.1 directly to 0.6.1 : bump2version --current-version 0.5.1 --new-version 0.6.1 patch setup.py ). tag = (True | False) [optional] default : False (Don't create a tag) Whether to create a tag, that is the new version, prefixed with the character \" v \". If you are using git, don't forget to git-push with the --tags flag. Also available on the command line as (--tag | --no-tag) . sign_tags = (True | False) [optional] default : False (Don't sign tags) Whether to sign tags. Also available on the command line as (--sign-tags | --no-sign-tags) . tag_name = [optional] default: v{new_version} The name of the tag that will be created. Only valid when using --tag / tag = True . This is templated using the Python Format String Syntax . Available in the template context are current_version and new_version as well as current_[part] and new_[part] (e.g. ' current_major ' or ' new_patch '). In addition, all environment variables are exposed, prefixed with $ . You can also use the variables now or utcnow to get a current timestamp. Both accept datetime formatting (when used like as in {now:%d.%m.%Y} ). Also available as command-line flag tag-name . Example usage: bump2version --tag-name 'release-{new_version}' patch In addition, it is also possible to provide a tag message by using --tag-message TAG_MESSAGE . Example usage: bump2version --tag-name 'release-{new_version}' --tag-message \"Release {new_version}\" patch If neither tag message or sign tag is provided, bumpversion uses a lightweight tag in Git. Otherwise, it utilizes an annotated Git tag. You can read more about Git tagging here . commit = (True | False) [optional] default: False (Don't create a commit) Whether to create a commit using git or Mercurial. Also available as (--commit | --no-commit) . In many projects it is common to have a pre-commit hook that runs prior to a commit and in case of failure aborts the commit. For some use cases it might be desired that when bumping a version and having commit = True , the pre-commit hook should perform slightly different actions than in regular commits. For example run an extended set of checks only for actual releases of the software. To allow the pre-commit hooks to distinguish a bumpversion commit, the BUMPVERSION_CURRENT_VERSION and BUMPVERSION_NEW_VERSION environment variables are set when executing the commit command. message = [optional] default: Bump version: {current_version} \u2192 {new_version} The commit message to use when creating a commit. Only valid when using --commit / commit = True . This is templated using the Python Format String Syntax . Available in the template context are current_version and new_version as well as current_[part] and new_[part] (e.g. ' current_major ' or ' new_patch '). In addition, all environment variables are exposed, prefixed with $ . You can also use the variables now or utcnow to get a current timestamp. Both accept datetime formatting (when used like as in {now:%d.%m.%Y} ). Also available as command-line flag --message . Example usage: bump2version --message '[{now:%Y-%m-%d}] Jenkins Build {$BUILD_NUMBER}: {new_version}' patch ) commit_args = [optional default: empty Extra arguments to pass to commit command. Only valid when using --commit / commit = True . This is for example useful to add -s to generate Signed-off-by: line in the commit message. Multiple arguments can be specified on separate lines. Also available as command-line flag --commit-args , in which case only one argument can be specified. Configuration file -- Part specific configuration A version string consists of one or more parts, e.g. the version 1.0.2 has three parts, separated by a dot ( . ) character. In the default configuration these parts are named major , minor , patch , however you can customize that using the parse / serialize option. By default all parts are considered numeric, that is their initial value is 0 and they are increased as integers. Also, the value 0 is considered to be optional if it's not needed for serialization, i.e. the version 1.4.0 is equal to 1.4 if {major}.{minor} is given as a serialize value. For advanced versioning schemes, non-numeric parts may be desirable (e.g. to identify alpha or beta versions to indicate the stage of development, the flavor of the software package or a release name). To do so, you can use a [bumpversion:part:\u2026] section containing the part's name (e.g. a part named release_name is configured in a section called [bumpversion:part:release_name] . The following options are valid inside a part configuration: values = default : numeric (i.e. 0 , 1 , 2 , \u2026) Explicit list of all values that will be iterated when bumping that specific part. Example: [bumpversion:part:release_name] values = witty-warthog ridiculous-rat marvelous-mantis optional_value = default : The first entry in values = . If the value of the part matches this value it is considered optional, i.e. its representation in a --serialize possibility is not required. Example: [bumpversion] current_version = 1.alpha parse = (?P<num>\\d+)(\\.(?P<release>.*))? serialize = {num}.{release} {num} [bumpversion:part:release] optional_value = gamma values = alpha beta gamma Here, bump2version release would bump 1.alpha to 1.beta . Executing bump2version release again would bump 1.beta to 1 , because release being gamma is configured optional. first_value = default : The first entry in values = . When the part is reset, the value will be set to the value specified here. Configuration file -- File specific configuration This configuration is in the section: [bumpversion:file:\u2026] or [bumpversion:glob:\u2026] Both, file: and glob: are configured the same. Their difference is that file will match file names directly like requirements.txt . While glob also matches multiple files via wildcards like **/pom.xml . Note: The configuration file format requires each section header to be unique. If you want to process a certain file multiple times, you may append a description between parens to the file keyword: [bumpversion:file (special one):\u2026] . parse = default: (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+) Regular expression (using Python regular expression syntax ) on how to find and parse the version string. Is required to parse all strings produced by serialize = . Named matching groups (\" (?P<name>...) \") provide values to as the part argument. Also available as --parse serialize = default: {major}.{minor}.{patch} Template specifying how to serialize the version parts back to a version string. This is templated using the Python Format String Syntax . Available in the template context are parsed values of the named groups specified in parse = as well as all environment variables (prefixed with $ ). Can be specified multiple times, bumpversion will try the serialization formats beginning with the first and choose the last one where all values can be represented like this: serialize = {major}.{minor} {major} Given the example above, the new version 1.9 will be serialized as 1.9 , but the version 2.0 will be serialized as 2 . Also available as --serialize . Multiple values on the command line are given like --serialize {major}.{minor} --serialize {major} search = default: {current_version} Template string how to search for the string to be replaced in the file. Useful if the remotest possibility exists that the current version number might be present multiple times in the file and you mean to only bump one of the occurrences. Can be multiple lines, templated using Python Format String Syntax replace = default: {new_version} Template to create the string that will replace the current version number in the file. Given this requirements.txt : Django >= 1 . 5 . 6 , < 1 . 6 MyProject == 1 . 5 . 6 using this .bumpversion.cfg will ensure only the line containing MyProject will be changed: [bumpversion] current_version = 1.5.6 [bumpversion:file:requirements.txt] search = MyProject=={current_version} replace = MyProject=={new_version} Can be multiple lines, templated using Python Format String Syntax . Command-line Options Most of the configuration values above can also be given as an option on the command-line. Additionally, the following options are available: --dry-run, -n Don't touch any files, just pretend. Best used with --verbose . --allow-dirty Normally, bumpversion will abort if the working directory is dirty to protect yourself from releasing unversioned files and/or overwriting unsaved changes. Use this option to override this check. --no-configured-files Will not update/check files specified in the bumpversion.cfg. Similar to dry-run, but will also avoid checking the files. Also useful when you want to update just one file with e.g., bump2version --no-configured-files major my-file.txt --verbose Print useful information to stderr --list List machine readable information to stdout for consumption by other programs. Example output: current_version = 0 . 0 . 18 new_version = 0 . 0 . 19 -h, --help Print help and exit Using bumpversion in a script If you need to use the version generated by bumpversion in a script you can make use of the --list option, combined with grep and sed . Say for example that you are using git-flow to manage your project and want to automatically create a release. When you issue git flow release start you already need to know the new version, before applying the change. The standard way to get it in a bash script is bump2version --dry-run --list <part> | grep <field name> | sed -r s,\"^.*=\",, where part is as usual the part of the version number you are updating. You need to specify --dry-run to avoid bumpversion actually bumping the version number. For example, if you are updating the minor number and looking for the new version number this becomes bump2version --dry-run --list minor | grep new_version | sed -r s,\"^.*=\",, Using bumpversion to maintain a go.mod file within a Go project In a module-aware Go project, when you create a major version of your module beyond v1, your module name will need to include the major version # (e.g. github.com/myorg/myproject/v2 ). You can use bump2version to maintain the major version # within the go.mod file by using the parse and serialize options, as in this example: Example .bumpversion.cfg file: [ bumpversion ] current_version = 2.0.0 commit = True [ bumpversion:file:go.mod ] parse = ( ? P < major > \\ d + ) serialize = { major } search = module github . com / myorg / myproject / v { current_version } replace = module github . com / myorg / myproject / v { new_version } Example go.mod file: module github . com / myorg / myproject / v2 go 1.12 require ( ... ) Then run this command to create version 3.0.0 of your project: bump2version --new-version 3.0.0 major Your go.mod file now contains this module directive: module github . com / myorg / myproject / v3 Development & Contributing Thank you contributors! You can find a full list here: https://github.com/c4urself/bump2version/graphs/contributors See also our CONTRIBUTING.md Development of this happens on GitHub, patches including tests, documentation are very welcome, as well as bug reports! Also please open an issue if this tool does not support every aspect of bumping versions in your development workflow, as it is intended to be very versatile. License bump2version is licensed under the MIT License - see the LICENSE.rst file for details","title":"Home"},{"location":"#bump2version","text":"","title":"bump2version"},{"location":"#note","text":"This is a maintained fork of the excellent bumpversion project .","title":"NOTE"},{"location":"#overview","text":"Version-bump your software with a single command! A small command line tool to simplify releasing software by updating all version strings in your source code by the correct increment. Also creates commits and tags: version formats are highly configurable works without any VCS, but happily reads tag information from and writes commits and tags to Git and Mercurial if available just handles text files, so it's not specific to any programming language supports Python 3 and PyPy3 If you want to use Python 2, use pip>=9 and you'll get the last supported version, or pin bump2version<1 .","title":"Overview"},{"location":"#alternatives","text":"If bump2version does not fully suit your needs, you could take a look at other tools doing similar or related tasks: RELATED.md .","title":"Alternatives"},{"location":"#installation","text":"You can download and install the latest version of this software from the Python package index (PyPI) as follows: pip install --upgrade bump2version NOTE: pip install bumpversion now installs the latest bump2version!","title":"Installation"},{"location":"#changelog","text":"Please find the changelog here: CHANGELOG.md","title":"Changelog"},{"location":"#usage","text":"NOTE: Throughout this document you can use bumpversion or bump2version interchangeably. There are two modes of operation: On the command line for single-file operation and using a configuration file ( bumpversion.cfg ) for more complex multi-file operations. bump2version [ options ] part [ file ]","title":"Usage"},{"location":"#part","text":"required The part of the version to increase, e.g. minor . Valid values include those given in the --serialize / --parse option. Example bumping 0.5.1 to 0.6.0: bump2version --current-version 0.5.1 minor src/VERSION","title":"part"},{"location":"#file","text":"[optional] default : none The file that will be modified. This file is added to the list of files specified in [bumpversion:file:\u2026] sections from the configuration file. If you want to rewrite only files specified on the command line, use --no-configured-files . Example bumping 1.1.9 to 2.0.0: bump2version --current-version 1.1.9 major setup.py","title":"file"},{"location":"#configuration-file","text":"All options can optionally be specified in a config file called .bumpversion.cfg so that once you know how bump2version needs to be configured for one particular software package, you can run it without specifying options later. You should add that file to VCS so others can also bump versions. Options on the command line take precedence over those from the config file, which take precedence over those derived from the environment and then from the defaults. Example .bumpversion.cfg : [bumpversion] current_version = 0.2.9 commit = True tag = True [bumpversion:file:setup.py] If no .bumpversion.cfg exists, bump2version will also look into setup.cfg for configuration.","title":"Configuration file"},{"location":"#configuration-file-global-configuration","text":"General configuration is grouped in a [bumpversion] section.","title":"Configuration file -- Global configuration"},{"location":"#current_version","text":"required default : none The current version of the software package before bumping. Also available as --current-version (e.g. bump2version --current-version 0.5.1 patch setup.py )","title":"current_version"},{"location":"#new_version","text":"[optional] default : none The version of the software package after the increment. If not given will be automatically determined. Also available as --new-version (e.g. to go from 0.5.1 directly to 0.6.1 : bump2version --current-version 0.5.1 --new-version 0.6.1 patch setup.py ).","title":"new_version"},{"location":"#tag-true-false","text":"[optional] default : False (Don't create a tag) Whether to create a tag, that is the new version, prefixed with the character \" v \". If you are using git, don't forget to git-push with the --tags flag. Also available on the command line as (--tag | --no-tag) .","title":"tag = (True | False)"},{"location":"#sign_tags-true-false","text":"[optional] default : False (Don't sign tags) Whether to sign tags. Also available on the command line as (--sign-tags | --no-sign-tags) .","title":"sign_tags = (True | False)"},{"location":"#tag_name","text":"[optional] default: v{new_version} The name of the tag that will be created. Only valid when using --tag / tag = True . This is templated using the Python Format String Syntax . Available in the template context are current_version and new_version as well as current_[part] and new_[part] (e.g. ' current_major ' or ' new_patch '). In addition, all environment variables are exposed, prefixed with $ . You can also use the variables now or utcnow to get a current timestamp. Both accept datetime formatting (when used like as in {now:%d.%m.%Y} ). Also available as command-line flag tag-name . Example usage: bump2version --tag-name 'release-{new_version}' patch In addition, it is also possible to provide a tag message by using --tag-message TAG_MESSAGE . Example usage: bump2version --tag-name 'release-{new_version}' --tag-message \"Release {new_version}\" patch If neither tag message or sign tag is provided, bumpversion uses a lightweight tag in Git. Otherwise, it utilizes an annotated Git tag. You can read more about Git tagging here .","title":"tag_name ="},{"location":"#commit-true-false","text":"[optional] default: False (Don't create a commit) Whether to create a commit using git or Mercurial. Also available as (--commit | --no-commit) . In many projects it is common to have a pre-commit hook that runs prior to a commit and in case of failure aborts the commit. For some use cases it might be desired that when bumping a version and having commit = True , the pre-commit hook should perform slightly different actions than in regular commits. For example run an extended set of checks only for actual releases of the software. To allow the pre-commit hooks to distinguish a bumpversion commit, the BUMPVERSION_CURRENT_VERSION and BUMPVERSION_NEW_VERSION environment variables are set when executing the commit command.","title":"commit = (True | False)"},{"location":"#message","text":"[optional] default: Bump version: {current_version} \u2192 {new_version} The commit message to use when creating a commit. Only valid when using --commit / commit = True . This is templated using the Python Format String Syntax . Available in the template context are current_version and new_version as well as current_[part] and new_[part] (e.g. ' current_major ' or ' new_patch '). In addition, all environment variables are exposed, prefixed with $ . You can also use the variables now or utcnow to get a current timestamp. Both accept datetime formatting (when used like as in {now:%d.%m.%Y} ). Also available as command-line flag --message . Example usage: bump2version --message '[{now:%Y-%m-%d}] Jenkins Build {$BUILD_NUMBER}: {new_version}' patch )","title":"message ="},{"location":"#commit_args","text":"[optional default: empty Extra arguments to pass to commit command. Only valid when using --commit / commit = True . This is for example useful to add -s to generate Signed-off-by: line in the commit message. Multiple arguments can be specified on separate lines. Also available as command-line flag --commit-args , in which case only one argument can be specified.","title":"commit_args ="},{"location":"#configuration-file-part-specific-configuration","text":"A version string consists of one or more parts, e.g. the version 1.0.2 has three parts, separated by a dot ( . ) character. In the default configuration these parts are named major , minor , patch , however you can customize that using the parse / serialize option. By default all parts are considered numeric, that is their initial value is 0 and they are increased as integers. Also, the value 0 is considered to be optional if it's not needed for serialization, i.e. the version 1.4.0 is equal to 1.4 if {major}.{minor} is given as a serialize value. For advanced versioning schemes, non-numeric parts may be desirable (e.g. to identify alpha or beta versions to indicate the stage of development, the flavor of the software package or a release name). To do so, you can use a [bumpversion:part:\u2026] section containing the part's name (e.g. a part named release_name is configured in a section called [bumpversion:part:release_name] . The following options are valid inside a part configuration:","title":"Configuration file -- Part specific configuration"},{"location":"#values","text":"default : numeric (i.e. 0 , 1 , 2 , \u2026) Explicit list of all values that will be iterated when bumping that specific part. Example: [bumpversion:part:release_name] values = witty-warthog ridiculous-rat marvelous-mantis","title":"values ="},{"location":"#optional_value","text":"default : The first entry in values = . If the value of the part matches this value it is considered optional, i.e. its representation in a --serialize possibility is not required. Example: [bumpversion] current_version = 1.alpha parse = (?P<num>\\d+)(\\.(?P<release>.*))? serialize = {num}.{release} {num} [bumpversion:part:release] optional_value = gamma values = alpha beta gamma Here, bump2version release would bump 1.alpha to 1.beta . Executing bump2version release again would bump 1.beta to 1 , because release being gamma is configured optional.","title":"optional_value ="},{"location":"#first_value","text":"default : The first entry in values = . When the part is reset, the value will be set to the value specified here.","title":"first_value ="},{"location":"#configuration-file-file-specific-configuration","text":"This configuration is in the section: [bumpversion:file:\u2026] or [bumpversion:glob:\u2026] Both, file: and glob: are configured the same. Their difference is that file will match file names directly like requirements.txt . While glob also matches multiple files via wildcards like **/pom.xml . Note: The configuration file format requires each section header to be unique. If you want to process a certain file multiple times, you may append a description between parens to the file keyword: [bumpversion:file (special one):\u2026] .","title":"Configuration file -- File specific configuration"},{"location":"#parse","text":"default: (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+) Regular expression (using Python regular expression syntax ) on how to find and parse the version string. Is required to parse all strings produced by serialize = . Named matching groups (\" (?P<name>...) \") provide values to as the part argument. Also available as --parse","title":"parse ="},{"location":"#serialize","text":"default: {major}.{minor}.{patch} Template specifying how to serialize the version parts back to a version string. This is templated using the Python Format String Syntax . Available in the template context are parsed values of the named groups specified in parse = as well as all environment variables (prefixed with $ ). Can be specified multiple times, bumpversion will try the serialization formats beginning with the first and choose the last one where all values can be represented like this: serialize = {major}.{minor} {major} Given the example above, the new version 1.9 will be serialized as 1.9 , but the version 2.0 will be serialized as 2 . Also available as --serialize . Multiple values on the command line are given like --serialize {major}.{minor} --serialize {major}","title":"serialize ="},{"location":"#search","text":"default: {current_version} Template string how to search for the string to be replaced in the file. Useful if the remotest possibility exists that the current version number might be present multiple times in the file and you mean to only bump one of the occurrences. Can be multiple lines, templated using Python Format String Syntax","title":"search ="},{"location":"#replace","text":"default: {new_version} Template to create the string that will replace the current version number in the file. Given this requirements.txt : Django >= 1 . 5 . 6 , < 1 . 6 MyProject == 1 . 5 . 6 using this .bumpversion.cfg will ensure only the line containing MyProject will be changed: [bumpversion] current_version = 1.5.6 [bumpversion:file:requirements.txt] search = MyProject=={current_version} replace = MyProject=={new_version} Can be multiple lines, templated using Python Format String Syntax .","title":"replace ="},{"location":"#command-line-options","text":"Most of the configuration values above can also be given as an option on the command-line. Additionally, the following options are available: --dry-run, -n Don't touch any files, just pretend. Best used with --verbose . --allow-dirty Normally, bumpversion will abort if the working directory is dirty to protect yourself from releasing unversioned files and/or overwriting unsaved changes. Use this option to override this check. --no-configured-files Will not update/check files specified in the bumpversion.cfg. Similar to dry-run, but will also avoid checking the files. Also useful when you want to update just one file with e.g., bump2version --no-configured-files major my-file.txt --verbose Print useful information to stderr --list List machine readable information to stdout for consumption by other programs. Example output: current_version = 0 . 0 . 18 new_version = 0 . 0 . 19 -h, --help Print help and exit","title":"Command-line Options"},{"location":"#using-bumpversion-in-a-script","text":"If you need to use the version generated by bumpversion in a script you can make use of the --list option, combined with grep and sed . Say for example that you are using git-flow to manage your project and want to automatically create a release. When you issue git flow release start you already need to know the new version, before applying the change. The standard way to get it in a bash script is bump2version --dry-run --list <part> | grep <field name> | sed -r s,\"^.*=\",, where part is as usual the part of the version number you are updating. You need to specify --dry-run to avoid bumpversion actually bumping the version number. For example, if you are updating the minor number and looking for the new version number this becomes bump2version --dry-run --list minor | grep new_version | sed -r s,\"^.*=\",,","title":"Using bumpversion in a script"},{"location":"#using-bumpversion-to-maintain-a-gomod-file-within-a-go-project","text":"In a module-aware Go project, when you create a major version of your module beyond v1, your module name will need to include the major version # (e.g. github.com/myorg/myproject/v2 ). You can use bump2version to maintain the major version # within the go.mod file by using the parse and serialize options, as in this example: Example .bumpversion.cfg file: [ bumpversion ] current_version = 2.0.0 commit = True [ bumpversion:file:go.mod ] parse = ( ? P < major > \\ d + ) serialize = { major } search = module github . com / myorg / myproject / v { current_version } replace = module github . com / myorg / myproject / v { new_version } Example go.mod file: module github . com / myorg / myproject / v2 go 1.12 require ( ... ) Then run this command to create version 3.0.0 of your project: bump2version --new-version 3.0.0 major Your go.mod file now contains this module directive: module github . com / myorg / myproject / v3","title":"Using bumpversion to maintain a go.mod file within a Go project"},{"location":"#development-contributing","text":"Thank you contributors! You can find a full list here: https://github.com/c4urself/bump2version/graphs/contributors See also our CONTRIBUTING.md Development of this happens on GitHub, patches including tests, documentation are very welcome, as well as bug reports! Also please open an issue if this tool does not support every aspect of bumping versions in your development workflow, as it is intended to be very versatile.","title":"Development &amp; Contributing"},{"location":"#license","text":"bump2version is licensed under the MIT License - see the LICENSE.rst file for details","title":"License"},{"location":"CHANGELOG/","text":"unreleased v1.0.2-dev v1.0.1 - Added: enable special characters in search/replace, thanks @mckelvin - Added: allow globbing a pattern to match multiple files, thanks @balrok - Added: way to only bump a specified file via --no-configured-files, thanks @balrok - Fixed: dry-run now correctly outputs, thanks @fmigneault - Housekeeping: documentation for lightweight tags improved, thanks @GreatBahram - Housekeeping: added related tools document, thanks @florisla - Fixed: no more falling back to default search, thanks @florisla v1.0.0 - Fix the spurious newline that bump2version adds when writing to bumpversion.cfg, thanks @kyluca #58 - Add Python3.8 support, thanks @florisla - Drop Python2 support, thanks @hugovk - Allow additional arguments to the commit call, thanks @lubomir - Various documentation improvements, thanks @lubomir @florisla @padamstx @glotis - Housekeeping, move changelog into own file v0.5.11 Housekeeping, also publish an sdist Housekeeping, fix appveyor builds Housekeeping, make lint now lints with pylint Drop support for Python3.4, thanks @hugovk #79 Enhance missing VCS command detection (errno 13), thanks @lowell80 #75 Add environment variables for other scripts to use, thanks @mauvilsa #70 Refactor, cli.main is now much more readable, thanks @florisla #68 Fix, retain file newlines for Windows, thanks @hesstobi #59 Add support (tests) for Pythno3.7, thanks @florisla #49 Allow any part to be configured in configurable strings such as tag_name etc., thanks @florisla #41 v0.5.10 Housekeeping, use twine v0.5.9 Fixed windows appveyor-based testing, thanks: @jeremycarroll #33 and #34 Fixed interpolating correctly when using setup.cfg for config, thanks: @SethMMorton #32 Improve tox/travis testing, thanks: @ekohl #27 Fixed markdown formatting in setup.py for pypi.org documentation, thanks: @florisla, @Mattwmaster58 #26 v0.5.8 Updated the readme to markdown for easier maintainability Fixed travis testing, thanks: @sharksforarms #15 Added support for newlines, thanks: @sharksforarms #14 Fixed an issue with a TypeError on Windows, thanks: @lorengordon #12 Standardised the python versions, thanks: @ekohl #8 Fixed testing for pypy, #7 v0.5.7 Added support for signing tags (git tag -s) thanks: @Californian #6 v0.5.6 Added compatibility with bumpversion by making script install as bumpversion as well thanks: @the-allanc #2 v0.5.5 Added support for annotated tags thanks: @ekohl @gvangool #58 v0.5.4 Renamed to bump2version to ensure no conflicts with original package v0.5.3 Fix bug where --new-version value was not used when config was present (thanks @cscetbon @ecordell #60 Preserve case of keys config file (thanks theskumar #75 Windows CRLF improvements (thanks @thebjorn) v0.5.1 Document file specific options search = and replace = (introduced in 0.5.0) Fix parsing individual labels from serialize = config even if there are characters after the last label (thanks @mskrajnowski #56 Fix: Don't crash in git repositories that have tags that contain hyphens #51 and #52 Fix: Log actual content of the config file, not what ConfigParser prints after reading it. Fix: Support multiline values in search = also load configuration from setup.cfg , thanks @t-8ch #57 v0.5.0 This is a major one, containing two larger features, that require some changes in the configuration format. This release is fully backwards compatible to v0.4.1 , however deprecates two uses that will be removed in a future version. New feature: Part specific configuration New feature: File specific configuration New feature: parse option can now span multiple line (allows to comment complex regular expressions. See re.VERBOSE in the Python documentation for details, also see this testcase as an example. New feature: --allow-dirty #42 Fix: Save the files in binary mode to avoid mutating newlines (thanks @jaraco #45 License: bumpversion is now licensed under the MIT License #47 Deprecate multiple files on the command line (use a configuration file instead, or invoke bumpversion multiple times) Deprecate 'files =' configuration (use file specific configuration instead) v0.4.1 Add --list option #39 Use temporary files for handing over commit/tag messages to git/hg #36 Fix: don't encode stdout as utf-8 on py3 #40 Fix: logging of content of config file was wrong v0.4.0 Add --verbose option #21 #30 Allow option --serialize multiple times v0.3.8 Fix: --parse/--serialize didn't work from cfg #34 v0.3.7 Don't fail if git or hg is not installed (thanks @keimlink) \"files\" option is now optional #16 Fix bug related to dirty work dir #28 v0.3.6 Fix --tag default (thanks @keimlink) v0.3.5 add {now} and {utcnow} to context use correct file encoding writing to config file. NOTE: If you are using Python2 and want to use UTF-8 encoded characters in your config file, you need to update ConfigParser like using 'pip install -U configparser' leave current_version in config even if available from vcs tags (was confusing) print own version number in usage allow bumping parts that contain non-numerics various fixes regarding file encoding v0.3.4 bugfix: tag_name and message in .bumpversion.cfg didn't have an effect #9 v0.3.3 add --tag-name option now works on Python 3.2, 3.3 and PyPy v0.3.2 bugfix: Read only tags from git describe that look like versions v0.3.1 bugfix: --help in git workdir raising AssertionError bugfix: fail earlier if one of files does not exist bugfix: commit = True / tag = True in .bumpversion.cfg had no effect v0.3.0 BREAKING CHANGE The --bump argument was removed, this is now the first positional argument. If you used bumpversion --bump major before, you can use bumpversion major now. If you used bumpversion without arguments before, you now need to specify the part (previous default was patch ) as in bumpversion patch ). v0.2.2 add --no-commit, --no-tag v0.2.1 If available, use git to learn about current version v0.2.0 Mercurial support v0.1.1 Only create a tag when it's requested (thanks @gvangool) v0.1.0 Initial public version","title":"Changelog"},{"location":"CONTRIBUTING/","text":"How to contribute We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. Guidelines Write your patch Add a test case to your patch Make sure that make test runs properly Send your patch as a PR Setup Fork & clone the repo Install Docker Install docker-compose Run make test from the root directory How to release bumpversion itself Execute the following commands: git checkout master git pull make test make lint bump2version release make dist make upload bump2version --no-tag patch git push origin master --tags","title":"Contributing"},{"location":"CONTRIBUTING/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.","title":"How to contribute"},{"location":"CONTRIBUTING/#guidelines","text":"Write your patch Add a test case to your patch Make sure that make test runs properly Send your patch as a PR","title":"Guidelines"},{"location":"CONTRIBUTING/#setup","text":"Fork & clone the repo Install Docker Install docker-compose Run make test from the root directory","title":"Setup"},{"location":"CONTRIBUTING/#how-to-release-bumpversion-itself","text":"Execute the following commands: git checkout master git pull make test make lint bump2version release make dist make upload bump2version --no-tag patch git push origin master --tags","title":"How to release bumpversion itself"},{"location":"RELATED/","text":"Similar or related tools bumpversion is the original project off of which bump2version was forked. We'll be merging back with them at some point (issue #86 ). tbump is a complete rewrite, with a nicer UX and additional features, like running commands (aka hooks) before or after the bump. It only works for Git repos right now. ADVbumpversion is another fork. It offers some features which are still work in progress here; it's definitely our desire to merge back (issue #121 ). zest.releaser manages your Python package releases and keeps the version number in one location. setuptools-scm relies on version control tags and the state of your working copy to determine the version number. incremental integrates into setuptools and maintains the version number in _version.py . Invocations packaging.release are a set of tasks for invoke . These assume your version is in _version.py and you're using semantic versioning. python-semantic.release automatically bumps your (semantic) version number based on the types of commits (breaking/new/bugfix) in your source control. PyCalVer is very similar to bump2version, but with support for calendar based versioning . Change log building towncrier assembles a changelog file from multiple snippets found in individual (merge) commits. releases helps build a Sphinx ReStructuredText changelog. gitchangelog searches the git commit history to make a configurable changelog file.","title":"Related"},{"location":"RELATED/#similar-or-related-tools","text":"bumpversion is the original project off of which bump2version was forked. We'll be merging back with them at some point (issue #86 ). tbump is a complete rewrite, with a nicer UX and additional features, like running commands (aka hooks) before or after the bump. It only works for Git repos right now. ADVbumpversion is another fork. It offers some features which are still work in progress here; it's definitely our desire to merge back (issue #121 ). zest.releaser manages your Python package releases and keeps the version number in one location. setuptools-scm relies on version control tags and the state of your working copy to determine the version number. incremental integrates into setuptools and maintains the version number in _version.py . Invocations packaging.release are a set of tasks for invoke . These assume your version is in _version.py and you're using semantic versioning. python-semantic.release automatically bumps your (semantic) version number based on the types of commits (breaking/new/bugfix) in your source control. PyCalVer is very similar to bump2version, but with support for calendar based versioning .","title":"Similar or related tools"},{"location":"RELATED/#change-log-building","text":"towncrier assembles a changelog file from multiple snippets found in individual (merge) commits. releases helps build a Sphinx ReStructuredText changelog. gitchangelog searches the git commit history to make a configurable changelog file.","title":"Change log building"},{"location":"reference/bumpversion/","text":"Module bumpversion View Source __version__ = \"1.0.2-dev\" __license__ = \"MIT\" __title__ = \"bumpversion\" Sub-modules bumpversion.cli bumpversion.exceptions bumpversion.functions bumpversion.utils bumpversion.vcs bumpversion.version_part","title":"Index"},{"location":"reference/bumpversion/#module-bumpversion","text":"View Source __version__ = \"1.0.2-dev\" __license__ = \"MIT\" __title__ = \"bumpversion\"","title":"Module bumpversion"},{"location":"reference/bumpversion/#sub-modules","text":"bumpversion.cli bumpversion.exceptions bumpversion.functions bumpversion.utils bumpversion.vcs bumpversion.version_part","title":"Sub-modules"},{"location":"reference/bumpversion/cli/","text":"Module bumpversion.cli View Source import argparse from datetime import datetime import glob import io import itertools import logging import os import re import sre_constants import sys import warnings from configparser import ( ConfigParser , RawConfigParser , NoOptionError , ) from bumpversion import __version__ , __title__ from bumpversion.version_part import ( VersionConfig , NumericVersionPartConfiguration , ConfiguredVersionPartConfiguration , ) from bumpversion.exceptions import ( IncompleteVersionRepresentationException , MissingValueForSerializationException , WorkingDirectoryIsDirtyException , ) from bumpversion.utils import ( ConfiguredFile , DiscardDefaultIfSpecifiedAppendAction , keyvaluestring , prefixed_environ , ) from bumpversion.vcs import Git , Mercurial DESCRIPTION = \"{}: v{} (using Python v{})\" . format ( __title__ , __version__ , sys . version . split ( \" \\n \" )[ 0 ] . split ( \" \" )[ 0 ] ) VCS = [ Git , Mercurial ] # detect either # bumpversion:part:value # bumpversion:file:value # bumpversion:file(suffix):value # bumpversion:file ( suffix with spaces):value RE_DETECT_SECTION_TYPE = re . compile ( r \"^bumpversion:\" r \"((?P<file>file|glob)(\\s*\\(\\s*(?P<file_suffix>[^\\):]+)\\)?)?|(?P<part>part)):\" r \"(?P<value>.+)\" , ) logger_list = logging . getLogger ( \"bumpversion.list\" ) logger = logging . getLogger ( __name__ ) time_context = { \"now\" : datetime . now (), \"utcnow\" : datetime . utcnow ()} special_char_context = { c : c for c in ( \"#\" , \";\" )} OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES = [ \"--config-file\" , \"--current-version\" , \"--message\" , \"--new-version\" , \"--parse\" , \"--serialize\" , \"--search\" , \"--replace\" , \"--tag-name\" , \"--tag-message\" , \"-m\" , ] def main ( original_args = None ): # determine configuration based on command-line arguments # and on-disk configuration files args , known_args , root_parser , positionals = _parse_arguments_phase_1 ( original_args ) _setup_logging ( known_args . list , known_args . verbose ) vcs_info = _determine_vcs_usability () defaults = _determine_current_version ( vcs_info ) explicit_config = None if hasattr ( known_args , \"config_file\" ): explicit_config = known_args . config_file config_file = _determine_config_file ( explicit_config ) config , config_file_exists , config_newlines , part_configs , files = _load_configuration ( config_file , explicit_config , defaults , ) known_args , parser2 , remaining_argv = _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ) version_config = _setup_versionconfig ( known_args , part_configs ) current_version = version_config . parse ( known_args . current_version ) context = dict ( itertools . chain ( time_context . items (), prefixed_environ () . items (), vcs_info . items (), special_char_context . items (), ) ) # calculate the desired new version new_version = _assemble_new_version ( context , current_version , defaults , known_args . current_version , positionals , version_config ) args , file_names = _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ) new_version = _parse_new_version ( args , new_version , version_config ) # do not use the files from the config if args . no_configured_files : files = [] # replace version in target files vcs = _determine_vcs_dirty ( VCS , defaults ) files . extend ( ConfiguredFile ( file_name , version_config ) for file_name in ( file_names or positionals [ 1 :]) ) _check_files_contain_version ( files , current_version , context ) _replace_version_in_files ( files , current_version , new_version , args . dry_run , context ) _log_list ( config , args . new_version ) # store the new version _update_config_file ( config , config_file , config_newlines , config_file_exists , args . new_version , args . dry_run , ) # commit and tag if vcs : context = _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ) _tag_in_vcs ( vcs , context , args ) def split_args_in_optional_and_positional ( args ): # manually parsing positional arguments because stupid argparse can't mix # positional and optional arguments positions = [] for i , arg in enumerate ( args ): previous = None if i > 0 : previous = args [ i - 1 ] if ( not arg . startswith ( \"-\" )) and ( previous not in OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES ): positions . append ( i ) positionals = [ arg for i , arg in enumerate ( args ) if i in positions ] args = [ arg for i , arg in enumerate ( args ) if i not in positions ] return ( positionals , args ) def _parse_arguments_phase_1 ( original_args ): positionals , args = split_args_in_optional_and_positional ( sys . argv [ 1 :] if original_args is None else original_args ) if len ( positionals [ 1 :]) > 2 : warnings . warn ( \"Giving multiple files on the command line will be deprecated, \" \"please use [bumpversion:file:...] in a config file.\" , PendingDeprecationWarning , ) root_parser = argparse . ArgumentParser ( add_help = False ) root_parser . add_argument ( \"--config-file\" , metavar = \"FILE\" , default = argparse . SUPPRESS , required = False , help = \"Config file to read most of the variables from (default: .bumpversion.cfg)\" , ) root_parser . add_argument ( \"--verbose\" , action = \"count\" , default = 0 , help = \"Print verbose logging to stderr\" , required = False , ) root_parser . add_argument ( \"--list\" , action = \"store_true\" , default = False , help = \"List machine readable information\" , required = False , ) root_parser . add_argument ( \"--allow-dirty\" , action = \"store_true\" , default = False , help = \"Don't abort if working directory is dirty\" , required = False , ) known_args , _ = root_parser . parse_known_args ( args ) return args , known_args , root_parser , positionals def _setup_logging ( show_list , verbose ): logformatter = logging . Formatter ( \" %(message)s \" ) if not logger . handlers : ch1 = logging . StreamHandler ( sys . stderr ) ch1 . setFormatter ( logformatter ) logger . addHandler ( ch1 ) if not logger_list . handlers : ch2 = logging . StreamHandler ( sys . stdout ) ch2 . setFormatter ( logformatter ) logger_list . addHandler ( ch2 ) if show_list : logger_list . setLevel ( logging . DEBUG ) try : log_level = [ logging . WARNING , logging . INFO , logging . DEBUG ][ verbose ] except IndexError : log_level = logging . DEBUG root_logger = logging . getLogger ( '' ) root_logger . setLevel ( log_level ) logger . debug ( \"Starting %s \" , DESCRIPTION ) def _determine_vcs_usability (): vcs_info = {} for vcs in VCS : if vcs . is_usable (): vcs_info . update ( vcs . latest_tag_info ()) return vcs_info def _determine_current_version ( vcs_info ): defaults = {} if \"current_version\" in vcs_info : defaults [ \"current_version\" ] = vcs_info [ \"current_version\" ] return defaults def _determine_config_file ( explicit_config ): if explicit_config : return explicit_config if not os . path . exists ( \".bumpversion.cfg\" ) and os . path . exists ( \"setup.cfg\" ): return \"setup.cfg\" return \".bumpversion.cfg\" def _load_configuration ( config_file , explicit_config , defaults ): # setup.cfg supports interpolation - for compatibility we must do the same. if os . path . basename ( config_file ) == \"setup.cfg\" : config = ConfigParser ( \"\" ) else : config = RawConfigParser ( \"\" ) # don't transform keys to lowercase (which would be the default) config . optionxform = lambda option : option config . add_section ( \"bumpversion\" ) config_file_exists = os . path . exists ( config_file ) if not config_file_exists : message = \"Could not read config file at {}\" . format ( config_file ) if explicit_config : raise argparse . ArgumentTypeError ( message ) logger . info ( message ) return config , config_file_exists , None , {}, [] logger . info ( \"Reading config file %s :\" , config_file ) with open ( config_file , \"rt\" , encoding = \"utf-8\" ) as config_fp : config_content = config_fp . read () config_newlines = config_fp . newlines # TODO: this is a DEBUG level log logger . info ( config_content ) config . read_string ( config_content ) log_config = io . StringIO () config . write ( log_config ) if config . has_option ( \"bumpversion\" , \"files\" ): warnings . warn ( \"'files =' configuration will be deprecated, please use [bumpversion:file:...]\" , PendingDeprecationWarning , ) defaults . update ( dict ( config . items ( \"bumpversion\" ))) for listvaluename in ( \"serialize\" ,): try : value = config . get ( \"bumpversion\" , listvaluename ) defaults [ listvaluename ] = list ( filter ( None , ( x . strip () for x in value . splitlines ())) ) except NoOptionError : pass # no default value then ;) for boolvaluename in ( \"commit\" , \"tag\" , \"dry_run\" ): try : defaults [ boolvaluename ] = config . getboolean ( \"bumpversion\" , boolvaluename ) except NoOptionError : pass # no default value then ;) part_configs = {} files = [] for section_name in config . sections (): section_type_match = RE_DETECT_SECTION_TYPE . match ( section_name ) if not section_type_match : continue section_type = section_type_match . groupdict () section_value = section_type . get ( \"value\" ) section_config = dict ( config . items ( section_name )) if section_type . get ( \"part\" ): ThisVersionPartConfiguration = NumericVersionPartConfiguration if \"values\" in section_config : section_config [ \"values\" ] = list ( filter ( None , ( x . strip () for x in section_config [ \"values\" ] . splitlines ()), ) ) ThisVersionPartConfiguration = ConfiguredVersionPartConfiguration part_configs [ section_value ] = ThisVersionPartConfiguration ( ** section_config ) elif section_type . get ( \"file\" ): filename = section_value if \"serialize\" in section_config : section_config [ \"serialize\" ] = list ( filter ( None , ( x . strip () . replace ( \" \\\\ n\" , \" \\n \" ) for x in section_config [ \"serialize\" ] . splitlines () ), ) ) section_config [ \"part_configs\" ] = part_configs if \"parse\" not in section_config : section_config [ \"parse\" ] = defaults . get ( \"parse\" , r \"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\" ) if \"serialize\" not in section_config : section_config [ \"serialize\" ] = defaults . get ( \"serialize\" , [ \"{major}.{minor}.{patch}\" ] ) if \"search\" not in section_config : section_config [ \"search\" ] = defaults . get ( \"search\" , \"{current_version}\" ) if \"replace\" not in section_config : section_config [ \"replace\" ] = defaults . get ( \"replace\" , \"{new_version}\" ) version_config = VersionConfig ( ** section_config ) if section_type . get ( \"file\" ) == \"glob\" : for filename_glob in glob . glob ( filename , recursive = True ): files . append ( ConfiguredFile ( filename_glob , version_config )) else : files . append ( ConfiguredFile ( filename , version_config )) return config , config_file_exists , config_newlines , part_configs , files def _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ): parser2 = argparse . ArgumentParser ( prog = \"bumpversion\" , add_help = False , parents = [ root_parser ] ) parser2 . set_defaults ( ** defaults ) parser2 . add_argument ( \"--current-version\" , metavar = \"VERSION\" , help = \"Version that needs to be updated\" , required = False , ) parser2 . add_argument ( \"--parse\" , metavar = \"REGEX\" , help = \"Regex parsing the version string\" , default = defaults . get ( \"parse\" , r \"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\" ), ) parser2 . add_argument ( \"--serialize\" , metavar = \"FORMAT\" , action = DiscardDefaultIfSpecifiedAppendAction , help = \"How to format what is parsed back to a version\" , default = defaults . get ( \"serialize\" , [ \"{major}.{minor}.{patch}\" ]), ) parser2 . add_argument ( \"--search\" , metavar = \"SEARCH\" , help = \"Template for complete string to search\" , default = defaults . get ( \"search\" , \"{current_version}\" ), ) parser2 . add_argument ( \"--replace\" , metavar = \"REPLACE\" , help = \"Template for complete string to replace\" , default = defaults . get ( \"replace\" , \"{new_version}\" ), ) known_args , remaining_argv = parser2 . parse_known_args ( args ) defaults . update ( vars ( known_args )) assert isinstance ( known_args . serialize , list ), \"Argument `serialize` must be a list\" return known_args , parser2 , remaining_argv def _setup_versionconfig ( known_args , part_configs ): try : version_config = VersionConfig ( parse = known_args . parse , serialize = known_args . serialize , search = known_args . search , replace = known_args . replace , part_configs = part_configs , ) except sre_constants . error : # TODO: use re.error here mayhaps, also: should we log? sys . exit ( 1 ) return version_config def _assemble_new_version ( context , current_version , defaults , arg_current_version , positionals , version_config ): new_version = None if \"new_version\" not in defaults and arg_current_version : try : if current_version and positionals : logger . info ( \"Attempting to increment part ' %s '\" , positionals [ 0 ]) new_version = current_version . bump ( positionals [ 0 ], version_config . order ()) logger . info ( \"Values are now: %s \" , keyvaluestring ( new_version . _values )) defaults [ \"new_version\" ] = version_config . serialize ( new_version , context ) except MissingValueForSerializationException as e : logger . info ( \"Opportunistic finding of new_version failed: %s \" , e . message ) except IncompleteVersionRepresentationException as e : logger . info ( \"Opportunistic finding of new_version failed: %s \" , e . message ) except KeyError as e : logger . info ( \"Opportunistic finding of new_version failed\" ) return new_version def _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ): parser3 = argparse . ArgumentParser ( prog = \"bumpversion\" , description = DESCRIPTION , formatter_class = argparse . ArgumentDefaultsHelpFormatter , conflict_handler = \"resolve\" , parents = [ parser2 ], ) parser3 . set_defaults ( ** defaults ) parser3 . add_argument ( \"--current-version\" , metavar = \"VERSION\" , help = \"Version that needs to be updated\" , required = \"current_version\" not in defaults , ) parser3 . add_argument ( \"--no-configured-files\" , action = \"store_true\" , default = False , dest = \"no_configured_files\" , help = \"Only replace the version in files specified on the command line, ignoring the files from the configuration file.\" , ) parser3 . add_argument ( \"--dry-run\" , \"-n\" , action = \"store_true\" , default = False , help = \"Don't write any files, just pretend.\" , ) parser3 . add_argument ( \"--new-version\" , metavar = \"VERSION\" , help = \"New version that should be in the files\" , required = \"new_version\" not in defaults , ) commitgroup = parser3 . add_mutually_exclusive_group () commitgroup . add_argument ( \"--commit\" , action = \"store_true\" , dest = \"commit\" , help = \"Commit to version control\" , default = defaults . get ( \"commit\" , False ), ) commitgroup . add_argument ( \"--no-commit\" , action = \"store_false\" , dest = \"commit\" , help = \"Do not commit to version control\" , default = argparse . SUPPRESS , ) taggroup = parser3 . add_mutually_exclusive_group () taggroup . add_argument ( \"--tag\" , action = \"store_true\" , dest = \"tag\" , default = defaults . get ( \"tag\" , False ), help = \"Create a tag in version control\" , ) taggroup . add_argument ( \"--no-tag\" , action = \"store_false\" , dest = \"tag\" , help = \"Do not create a tag in version control\" , default = argparse . SUPPRESS , ) signtagsgroup = parser3 . add_mutually_exclusive_group () signtagsgroup . add_argument ( \"--sign-tags\" , action = \"store_true\" , dest = \"sign_tags\" , help = \"Sign tags if created\" , default = defaults . get ( \"sign_tags\" , False ), ) signtagsgroup . add_argument ( \"--no-sign-tags\" , action = \"store_false\" , dest = \"sign_tags\" , help = \"Do not sign tags if created\" , default = argparse . SUPPRESS , ) parser3 . add_argument ( \"--tag-name\" , metavar = \"TAG_NAME\" , help = \"Tag name (only works with --tag)\" , default = defaults . get ( \"tag_name\" , \"v{new_version}\" ), ) parser3 . add_argument ( \"--tag-message\" , metavar = \"TAG_MESSAGE\" , dest = \"tag_message\" , help = \"Tag message\" , default = defaults . get ( \"tag_message\" , \"Bump version: {current_version} \u2192 {new_version}\" ), ) parser3 . add_argument ( \"--message\" , \"-m\" , metavar = \"COMMIT_MSG\" , help = \"Commit message\" , default = defaults . get ( \"message\" , \"Bump version: {current_version} \u2192 {new_version}\" ), ) parser3 . add_argument ( \"--commit-args\" , metavar = \"COMMIT_ARGS\" , help = \"Extra arguments to commit command\" , default = defaults . get ( \"commit_args\" , \"\" ), ) file_names = [] if \"files\" in defaults : assert defaults [ \"files\" ] is not None file_names = defaults [ \"files\" ] . split ( \" \" ) parser3 . add_argument ( \"part\" , help = \"Part of the version to be bumped.\" ) parser3 . add_argument ( \"files\" , metavar = \"file\" , nargs = \"*\" , help = \"Files to change\" , default = file_names ) args = parser3 . parse_args ( remaining_argv + positionals ) if args . dry_run : logger . info ( \"Dry run active, won't touch any files.\" ) return args , file_names def _parse_new_version ( args , new_version , vc ): if args . new_version : new_version = vc . parse ( args . new_version ) logger . info ( \"New version will be ' %s '\" , args . new_version ) return new_version def _determine_vcs_dirty ( possible_vcses , defaults ): for vcs in possible_vcses : if not vcs . is_usable (): continue try : vcs . assert_nondirty () except WorkingDirectoryIsDirtyException as e : if not defaults [ \"allow_dirty\" ]: logger . warning ( \" %s \\n\\n Use --allow-dirty to override this if you know what you're doing.\" , e . message , ) raise return vcs return None def _check_files_contain_version ( files , current_version , context ): # make sure files exist and contain version string logger . info ( \"Asserting files %s contain the version string...\" , \", \" . join ([ str ( f ) for f in files ]), ) for f in files : f . should_contain_version ( current_version , context ) def _replace_version_in_files ( files , current_version , new_version , dry_run , context ): # change version string in files for f in files : f . replace ( current_version , new_version , context , dry_run ) def _log_list ( config , new_version ): config . set ( \"bumpversion\" , \"new_version\" , new_version ) for key , value in config . items ( \"bumpversion\" ): logger_list . info ( \" %s = %s \" , key , value ) config . remove_option ( \"bumpversion\" , \"new_version\" ) def _update_config_file ( config , config_file , config_newlines , config_file_exists , new_version , dry_run , ): config . set ( \"bumpversion\" , \"current_version\" , new_version ) new_config = io . StringIO () try : write_to_config_file = ( not dry_run ) and config_file_exists logger . info ( \" %s to config file %s :\" , \"Would write\" if not write_to_config_file else \"Writing\" , config_file , ) config . write ( new_config ) logger . info ( new_config . getvalue ()) if write_to_config_file : with open ( config_file , \"wt\" , encoding = \"utf-8\" , newline = config_newlines ) as f : f . write ( new_config . getvalue () . strip () + \" \\n \" ) except UnicodeEncodeError : warnings . warn ( \"Unable to write UTF-8 to config file, because of an old configparser version. \" \"Update with `pip install --upgrade configparser`.\" ) def _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ): commit_files = [ f . path for f in files ] if config_file_exists : commit_files . append ( config_file ) assert vcs . is_usable (), \"Did find '{}' unusable, unable to commit.\" . format ( vcs . __name__ ) do_commit = args . commit and not args . dry_run logger . info ( \" %s %s commit\" , \"Would prepare\" if not do_commit else \"Preparing\" , vcs . __name__ , ) for path in commit_files : logger . info ( \" %s changes in file ' %s ' to %s \" , \"Would add\" if not do_commit else \"Adding\" , path , vcs . __name__ , ) if do_commit : vcs . add_path ( path ) context = { \"current_version\" : args . current_version , \"new_version\" : args . new_version , } context . update ( time_context ) context . update ( prefixed_environ ()) context . update ({ 'current_' + part : current_version [ part ] . value for part in current_version }) context . update ({ 'new_' + part : new_version [ part ] . value for part in new_version }) context . update ( special_char_context ) commit_message = args . message . format ( ** context ) logger . info ( \" %s to %s with message ' %s '\" , \"Would commit\" if not do_commit else \"Committing\" , vcs . __name__ , commit_message , ) if do_commit : vcs . commit ( message = commit_message , context = context , extra_args = [ arg . strip () for arg in args . commit_args . splitlines ()], ) return context def _tag_in_vcs ( vcs , context , args ): sign_tags = args . sign_tags tag_name = args . tag_name . format ( ** context ) tag_message = args . tag_message . format ( ** context ) do_tag = args . tag and not args . dry_run logger . info ( \" %s ' %s ' %s in %s and %s \" , \"Would tag\" if not do_tag else \"Tagging\" , tag_name , \"with message '{}'\" . format ( tag_message ) if tag_message else \"without message\" , vcs . __name__ , \"signing\" if sign_tags else \"not signing\" , ) if do_tag : vcs . tag ( sign_tags , tag_name , tag_message ) Variables DESCRIPTION OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES RE_DETECT_SECTION_TYPE VCS logger logger_list special_char_context time_context Functions main def main ( original_args = None ) View Source def main ( original_args = None ) : # determine configuration based on command - line arguments # and on - disk configuration files args , known_args , root_parser , positionals = _parse_arguments_phase_1 ( original_args ) _setup_logging ( known_args . list , known_args . verbose ) vcs_info = _determine_vcs_usability () defaults = _determine_current_version ( vcs_info ) explicit_config = None if hasattr ( known_args , \" config_file \" ) : explicit_config = known_args . config_file config_file = _determine_config_file ( explicit_config ) config , config_file_exists , config_newlines , part_configs , files = _load_configuration ( config_file , explicit_config , defaults , ) known_args , parser2 , remaining_argv = _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ) version_config = _setup_versionconfig ( known_args , part_configs ) current_version = version_config . parse ( known_args . current_version ) context = dict ( itertools . chain ( time_context . items () , prefixed_environ () . items () , vcs_info . items () , special_char_context . items () , ) ) # calculate the desired new version new_version = _assemble_new_version ( context , current_version , defaults , known_args . current_version , positionals , version_config ) args , file_names = _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ) new_version = _parse_new_version ( args , new_version , version_config ) # do not use the files from the config if args . no_configured_files : files = [] # replace version in target files vcs = _determine_vcs_dirty ( VCS , defaults ) files . extend ( ConfiguredFile ( file_name , version_config ) for file_name in ( file_names or positionals [ 1 :] ) ) _check_files_contain_version ( files , current_version , context ) _replace_version_in_files ( files , current_version , new_version , args . dry_run , context ) _log_list ( config , args . new_version ) # store the new version _update_config_file ( config , config_file , config_newlines , config_file_exists , args . new_version , args . dry_run , ) # commit and tag if vcs : context = _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ) _tag_in_vcs ( vcs , context , args ) split_args_in_optional_and_positional def split_args_in_optional_and_positional ( args ) View Source def split_args_in_optional_and_positional ( args ) : # manually parsing positional arguments because stupid argparse can ' t mix # positional and optional arguments positions = [] for i , arg in enumerate ( args ) : previous = None if i > 0 : previous = args [ i - 1 ] if ( not arg . startswith ( \" - \" )) and ( previous not in OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES ) : positions . append ( i ) positionals = [ arg for i , arg in enumerate ( args ) if i in positions ] args = [ arg for i , arg in enumerate ( args ) if i not in positions ] return ( positionals , args )","title":"CLI"},{"location":"reference/bumpversion/cli/#module-bumpversioncli","text":"View Source import argparse from datetime import datetime import glob import io import itertools import logging import os import re import sre_constants import sys import warnings from configparser import ( ConfigParser , RawConfigParser , NoOptionError , ) from bumpversion import __version__ , __title__ from bumpversion.version_part import ( VersionConfig , NumericVersionPartConfiguration , ConfiguredVersionPartConfiguration , ) from bumpversion.exceptions import ( IncompleteVersionRepresentationException , MissingValueForSerializationException , WorkingDirectoryIsDirtyException , ) from bumpversion.utils import ( ConfiguredFile , DiscardDefaultIfSpecifiedAppendAction , keyvaluestring , prefixed_environ , ) from bumpversion.vcs import Git , Mercurial DESCRIPTION = \"{}: v{} (using Python v{})\" . format ( __title__ , __version__ , sys . version . split ( \" \\n \" )[ 0 ] . split ( \" \" )[ 0 ] ) VCS = [ Git , Mercurial ] # detect either # bumpversion:part:value # bumpversion:file:value # bumpversion:file(suffix):value # bumpversion:file ( suffix with spaces):value RE_DETECT_SECTION_TYPE = re . compile ( r \"^bumpversion:\" r \"((?P<file>file|glob)(\\s*\\(\\s*(?P<file_suffix>[^\\):]+)\\)?)?|(?P<part>part)):\" r \"(?P<value>.+)\" , ) logger_list = logging . getLogger ( \"bumpversion.list\" ) logger = logging . getLogger ( __name__ ) time_context = { \"now\" : datetime . now (), \"utcnow\" : datetime . utcnow ()} special_char_context = { c : c for c in ( \"#\" , \";\" )} OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES = [ \"--config-file\" , \"--current-version\" , \"--message\" , \"--new-version\" , \"--parse\" , \"--serialize\" , \"--search\" , \"--replace\" , \"--tag-name\" , \"--tag-message\" , \"-m\" , ] def main ( original_args = None ): # determine configuration based on command-line arguments # and on-disk configuration files args , known_args , root_parser , positionals = _parse_arguments_phase_1 ( original_args ) _setup_logging ( known_args . list , known_args . verbose ) vcs_info = _determine_vcs_usability () defaults = _determine_current_version ( vcs_info ) explicit_config = None if hasattr ( known_args , \"config_file\" ): explicit_config = known_args . config_file config_file = _determine_config_file ( explicit_config ) config , config_file_exists , config_newlines , part_configs , files = _load_configuration ( config_file , explicit_config , defaults , ) known_args , parser2 , remaining_argv = _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ) version_config = _setup_versionconfig ( known_args , part_configs ) current_version = version_config . parse ( known_args . current_version ) context = dict ( itertools . chain ( time_context . items (), prefixed_environ () . items (), vcs_info . items (), special_char_context . items (), ) ) # calculate the desired new version new_version = _assemble_new_version ( context , current_version , defaults , known_args . current_version , positionals , version_config ) args , file_names = _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ) new_version = _parse_new_version ( args , new_version , version_config ) # do not use the files from the config if args . no_configured_files : files = [] # replace version in target files vcs = _determine_vcs_dirty ( VCS , defaults ) files . extend ( ConfiguredFile ( file_name , version_config ) for file_name in ( file_names or positionals [ 1 :]) ) _check_files_contain_version ( files , current_version , context ) _replace_version_in_files ( files , current_version , new_version , args . dry_run , context ) _log_list ( config , args . new_version ) # store the new version _update_config_file ( config , config_file , config_newlines , config_file_exists , args . new_version , args . dry_run , ) # commit and tag if vcs : context = _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ) _tag_in_vcs ( vcs , context , args ) def split_args_in_optional_and_positional ( args ): # manually parsing positional arguments because stupid argparse can't mix # positional and optional arguments positions = [] for i , arg in enumerate ( args ): previous = None if i > 0 : previous = args [ i - 1 ] if ( not arg . startswith ( \"-\" )) and ( previous not in OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES ): positions . append ( i ) positionals = [ arg for i , arg in enumerate ( args ) if i in positions ] args = [ arg for i , arg in enumerate ( args ) if i not in positions ] return ( positionals , args ) def _parse_arguments_phase_1 ( original_args ): positionals , args = split_args_in_optional_and_positional ( sys . argv [ 1 :] if original_args is None else original_args ) if len ( positionals [ 1 :]) > 2 : warnings . warn ( \"Giving multiple files on the command line will be deprecated, \" \"please use [bumpversion:file:...] in a config file.\" , PendingDeprecationWarning , ) root_parser = argparse . ArgumentParser ( add_help = False ) root_parser . add_argument ( \"--config-file\" , metavar = \"FILE\" , default = argparse . SUPPRESS , required = False , help = \"Config file to read most of the variables from (default: .bumpversion.cfg)\" , ) root_parser . add_argument ( \"--verbose\" , action = \"count\" , default = 0 , help = \"Print verbose logging to stderr\" , required = False , ) root_parser . add_argument ( \"--list\" , action = \"store_true\" , default = False , help = \"List machine readable information\" , required = False , ) root_parser . add_argument ( \"--allow-dirty\" , action = \"store_true\" , default = False , help = \"Don't abort if working directory is dirty\" , required = False , ) known_args , _ = root_parser . parse_known_args ( args ) return args , known_args , root_parser , positionals def _setup_logging ( show_list , verbose ): logformatter = logging . Formatter ( \" %(message)s \" ) if not logger . handlers : ch1 = logging . StreamHandler ( sys . stderr ) ch1 . setFormatter ( logformatter ) logger . addHandler ( ch1 ) if not logger_list . handlers : ch2 = logging . StreamHandler ( sys . stdout ) ch2 . setFormatter ( logformatter ) logger_list . addHandler ( ch2 ) if show_list : logger_list . setLevel ( logging . DEBUG ) try : log_level = [ logging . WARNING , logging . INFO , logging . DEBUG ][ verbose ] except IndexError : log_level = logging . DEBUG root_logger = logging . getLogger ( '' ) root_logger . setLevel ( log_level ) logger . debug ( \"Starting %s \" , DESCRIPTION ) def _determine_vcs_usability (): vcs_info = {} for vcs in VCS : if vcs . is_usable (): vcs_info . update ( vcs . latest_tag_info ()) return vcs_info def _determine_current_version ( vcs_info ): defaults = {} if \"current_version\" in vcs_info : defaults [ \"current_version\" ] = vcs_info [ \"current_version\" ] return defaults def _determine_config_file ( explicit_config ): if explicit_config : return explicit_config if not os . path . exists ( \".bumpversion.cfg\" ) and os . path . exists ( \"setup.cfg\" ): return \"setup.cfg\" return \".bumpversion.cfg\" def _load_configuration ( config_file , explicit_config , defaults ): # setup.cfg supports interpolation - for compatibility we must do the same. if os . path . basename ( config_file ) == \"setup.cfg\" : config = ConfigParser ( \"\" ) else : config = RawConfigParser ( \"\" ) # don't transform keys to lowercase (which would be the default) config . optionxform = lambda option : option config . add_section ( \"bumpversion\" ) config_file_exists = os . path . exists ( config_file ) if not config_file_exists : message = \"Could not read config file at {}\" . format ( config_file ) if explicit_config : raise argparse . ArgumentTypeError ( message ) logger . info ( message ) return config , config_file_exists , None , {}, [] logger . info ( \"Reading config file %s :\" , config_file ) with open ( config_file , \"rt\" , encoding = \"utf-8\" ) as config_fp : config_content = config_fp . read () config_newlines = config_fp . newlines # TODO: this is a DEBUG level log logger . info ( config_content ) config . read_string ( config_content ) log_config = io . StringIO () config . write ( log_config ) if config . has_option ( \"bumpversion\" , \"files\" ): warnings . warn ( \"'files =' configuration will be deprecated, please use [bumpversion:file:...]\" , PendingDeprecationWarning , ) defaults . update ( dict ( config . items ( \"bumpversion\" ))) for listvaluename in ( \"serialize\" ,): try : value = config . get ( \"bumpversion\" , listvaluename ) defaults [ listvaluename ] = list ( filter ( None , ( x . strip () for x in value . splitlines ())) ) except NoOptionError : pass # no default value then ;) for boolvaluename in ( \"commit\" , \"tag\" , \"dry_run\" ): try : defaults [ boolvaluename ] = config . getboolean ( \"bumpversion\" , boolvaluename ) except NoOptionError : pass # no default value then ;) part_configs = {} files = [] for section_name in config . sections (): section_type_match = RE_DETECT_SECTION_TYPE . match ( section_name ) if not section_type_match : continue section_type = section_type_match . groupdict () section_value = section_type . get ( \"value\" ) section_config = dict ( config . items ( section_name )) if section_type . get ( \"part\" ): ThisVersionPartConfiguration = NumericVersionPartConfiguration if \"values\" in section_config : section_config [ \"values\" ] = list ( filter ( None , ( x . strip () for x in section_config [ \"values\" ] . splitlines ()), ) ) ThisVersionPartConfiguration = ConfiguredVersionPartConfiguration part_configs [ section_value ] = ThisVersionPartConfiguration ( ** section_config ) elif section_type . get ( \"file\" ): filename = section_value if \"serialize\" in section_config : section_config [ \"serialize\" ] = list ( filter ( None , ( x . strip () . replace ( \" \\\\ n\" , \" \\n \" ) for x in section_config [ \"serialize\" ] . splitlines () ), ) ) section_config [ \"part_configs\" ] = part_configs if \"parse\" not in section_config : section_config [ \"parse\" ] = defaults . get ( \"parse\" , r \"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\" ) if \"serialize\" not in section_config : section_config [ \"serialize\" ] = defaults . get ( \"serialize\" , [ \"{major}.{minor}.{patch}\" ] ) if \"search\" not in section_config : section_config [ \"search\" ] = defaults . get ( \"search\" , \"{current_version}\" ) if \"replace\" not in section_config : section_config [ \"replace\" ] = defaults . get ( \"replace\" , \"{new_version}\" ) version_config = VersionConfig ( ** section_config ) if section_type . get ( \"file\" ) == \"glob\" : for filename_glob in glob . glob ( filename , recursive = True ): files . append ( ConfiguredFile ( filename_glob , version_config )) else : files . append ( ConfiguredFile ( filename , version_config )) return config , config_file_exists , config_newlines , part_configs , files def _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ): parser2 = argparse . ArgumentParser ( prog = \"bumpversion\" , add_help = False , parents = [ root_parser ] ) parser2 . set_defaults ( ** defaults ) parser2 . add_argument ( \"--current-version\" , metavar = \"VERSION\" , help = \"Version that needs to be updated\" , required = False , ) parser2 . add_argument ( \"--parse\" , metavar = \"REGEX\" , help = \"Regex parsing the version string\" , default = defaults . get ( \"parse\" , r \"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\" ), ) parser2 . add_argument ( \"--serialize\" , metavar = \"FORMAT\" , action = DiscardDefaultIfSpecifiedAppendAction , help = \"How to format what is parsed back to a version\" , default = defaults . get ( \"serialize\" , [ \"{major}.{minor}.{patch}\" ]), ) parser2 . add_argument ( \"--search\" , metavar = \"SEARCH\" , help = \"Template for complete string to search\" , default = defaults . get ( \"search\" , \"{current_version}\" ), ) parser2 . add_argument ( \"--replace\" , metavar = \"REPLACE\" , help = \"Template for complete string to replace\" , default = defaults . get ( \"replace\" , \"{new_version}\" ), ) known_args , remaining_argv = parser2 . parse_known_args ( args ) defaults . update ( vars ( known_args )) assert isinstance ( known_args . serialize , list ), \"Argument `serialize` must be a list\" return known_args , parser2 , remaining_argv def _setup_versionconfig ( known_args , part_configs ): try : version_config = VersionConfig ( parse = known_args . parse , serialize = known_args . serialize , search = known_args . search , replace = known_args . replace , part_configs = part_configs , ) except sre_constants . error : # TODO: use re.error here mayhaps, also: should we log? sys . exit ( 1 ) return version_config def _assemble_new_version ( context , current_version , defaults , arg_current_version , positionals , version_config ): new_version = None if \"new_version\" not in defaults and arg_current_version : try : if current_version and positionals : logger . info ( \"Attempting to increment part ' %s '\" , positionals [ 0 ]) new_version = current_version . bump ( positionals [ 0 ], version_config . order ()) logger . info ( \"Values are now: %s \" , keyvaluestring ( new_version . _values )) defaults [ \"new_version\" ] = version_config . serialize ( new_version , context ) except MissingValueForSerializationException as e : logger . info ( \"Opportunistic finding of new_version failed: %s \" , e . message ) except IncompleteVersionRepresentationException as e : logger . info ( \"Opportunistic finding of new_version failed: %s \" , e . message ) except KeyError as e : logger . info ( \"Opportunistic finding of new_version failed\" ) return new_version def _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ): parser3 = argparse . ArgumentParser ( prog = \"bumpversion\" , description = DESCRIPTION , formatter_class = argparse . ArgumentDefaultsHelpFormatter , conflict_handler = \"resolve\" , parents = [ parser2 ], ) parser3 . set_defaults ( ** defaults ) parser3 . add_argument ( \"--current-version\" , metavar = \"VERSION\" , help = \"Version that needs to be updated\" , required = \"current_version\" not in defaults , ) parser3 . add_argument ( \"--no-configured-files\" , action = \"store_true\" , default = False , dest = \"no_configured_files\" , help = \"Only replace the version in files specified on the command line, ignoring the files from the configuration file.\" , ) parser3 . add_argument ( \"--dry-run\" , \"-n\" , action = \"store_true\" , default = False , help = \"Don't write any files, just pretend.\" , ) parser3 . add_argument ( \"--new-version\" , metavar = \"VERSION\" , help = \"New version that should be in the files\" , required = \"new_version\" not in defaults , ) commitgroup = parser3 . add_mutually_exclusive_group () commitgroup . add_argument ( \"--commit\" , action = \"store_true\" , dest = \"commit\" , help = \"Commit to version control\" , default = defaults . get ( \"commit\" , False ), ) commitgroup . add_argument ( \"--no-commit\" , action = \"store_false\" , dest = \"commit\" , help = \"Do not commit to version control\" , default = argparse . SUPPRESS , ) taggroup = parser3 . add_mutually_exclusive_group () taggroup . add_argument ( \"--tag\" , action = \"store_true\" , dest = \"tag\" , default = defaults . get ( \"tag\" , False ), help = \"Create a tag in version control\" , ) taggroup . add_argument ( \"--no-tag\" , action = \"store_false\" , dest = \"tag\" , help = \"Do not create a tag in version control\" , default = argparse . SUPPRESS , ) signtagsgroup = parser3 . add_mutually_exclusive_group () signtagsgroup . add_argument ( \"--sign-tags\" , action = \"store_true\" , dest = \"sign_tags\" , help = \"Sign tags if created\" , default = defaults . get ( \"sign_tags\" , False ), ) signtagsgroup . add_argument ( \"--no-sign-tags\" , action = \"store_false\" , dest = \"sign_tags\" , help = \"Do not sign tags if created\" , default = argparse . SUPPRESS , ) parser3 . add_argument ( \"--tag-name\" , metavar = \"TAG_NAME\" , help = \"Tag name (only works with --tag)\" , default = defaults . get ( \"tag_name\" , \"v{new_version}\" ), ) parser3 . add_argument ( \"--tag-message\" , metavar = \"TAG_MESSAGE\" , dest = \"tag_message\" , help = \"Tag message\" , default = defaults . get ( \"tag_message\" , \"Bump version: {current_version} \u2192 {new_version}\" ), ) parser3 . add_argument ( \"--message\" , \"-m\" , metavar = \"COMMIT_MSG\" , help = \"Commit message\" , default = defaults . get ( \"message\" , \"Bump version: {current_version} \u2192 {new_version}\" ), ) parser3 . add_argument ( \"--commit-args\" , metavar = \"COMMIT_ARGS\" , help = \"Extra arguments to commit command\" , default = defaults . get ( \"commit_args\" , \"\" ), ) file_names = [] if \"files\" in defaults : assert defaults [ \"files\" ] is not None file_names = defaults [ \"files\" ] . split ( \" \" ) parser3 . add_argument ( \"part\" , help = \"Part of the version to be bumped.\" ) parser3 . add_argument ( \"files\" , metavar = \"file\" , nargs = \"*\" , help = \"Files to change\" , default = file_names ) args = parser3 . parse_args ( remaining_argv + positionals ) if args . dry_run : logger . info ( \"Dry run active, won't touch any files.\" ) return args , file_names def _parse_new_version ( args , new_version , vc ): if args . new_version : new_version = vc . parse ( args . new_version ) logger . info ( \"New version will be ' %s '\" , args . new_version ) return new_version def _determine_vcs_dirty ( possible_vcses , defaults ): for vcs in possible_vcses : if not vcs . is_usable (): continue try : vcs . assert_nondirty () except WorkingDirectoryIsDirtyException as e : if not defaults [ \"allow_dirty\" ]: logger . warning ( \" %s \\n\\n Use --allow-dirty to override this if you know what you're doing.\" , e . message , ) raise return vcs return None def _check_files_contain_version ( files , current_version , context ): # make sure files exist and contain version string logger . info ( \"Asserting files %s contain the version string...\" , \", \" . join ([ str ( f ) for f in files ]), ) for f in files : f . should_contain_version ( current_version , context ) def _replace_version_in_files ( files , current_version , new_version , dry_run , context ): # change version string in files for f in files : f . replace ( current_version , new_version , context , dry_run ) def _log_list ( config , new_version ): config . set ( \"bumpversion\" , \"new_version\" , new_version ) for key , value in config . items ( \"bumpversion\" ): logger_list . info ( \" %s = %s \" , key , value ) config . remove_option ( \"bumpversion\" , \"new_version\" ) def _update_config_file ( config , config_file , config_newlines , config_file_exists , new_version , dry_run , ): config . set ( \"bumpversion\" , \"current_version\" , new_version ) new_config = io . StringIO () try : write_to_config_file = ( not dry_run ) and config_file_exists logger . info ( \" %s to config file %s :\" , \"Would write\" if not write_to_config_file else \"Writing\" , config_file , ) config . write ( new_config ) logger . info ( new_config . getvalue ()) if write_to_config_file : with open ( config_file , \"wt\" , encoding = \"utf-8\" , newline = config_newlines ) as f : f . write ( new_config . getvalue () . strip () + \" \\n \" ) except UnicodeEncodeError : warnings . warn ( \"Unable to write UTF-8 to config file, because of an old configparser version. \" \"Update with `pip install --upgrade configparser`.\" ) def _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ): commit_files = [ f . path for f in files ] if config_file_exists : commit_files . append ( config_file ) assert vcs . is_usable (), \"Did find '{}' unusable, unable to commit.\" . format ( vcs . __name__ ) do_commit = args . commit and not args . dry_run logger . info ( \" %s %s commit\" , \"Would prepare\" if not do_commit else \"Preparing\" , vcs . __name__ , ) for path in commit_files : logger . info ( \" %s changes in file ' %s ' to %s \" , \"Would add\" if not do_commit else \"Adding\" , path , vcs . __name__ , ) if do_commit : vcs . add_path ( path ) context = { \"current_version\" : args . current_version , \"new_version\" : args . new_version , } context . update ( time_context ) context . update ( prefixed_environ ()) context . update ({ 'current_' + part : current_version [ part ] . value for part in current_version }) context . update ({ 'new_' + part : new_version [ part ] . value for part in new_version }) context . update ( special_char_context ) commit_message = args . message . format ( ** context ) logger . info ( \" %s to %s with message ' %s '\" , \"Would commit\" if not do_commit else \"Committing\" , vcs . __name__ , commit_message , ) if do_commit : vcs . commit ( message = commit_message , context = context , extra_args = [ arg . strip () for arg in args . commit_args . splitlines ()], ) return context def _tag_in_vcs ( vcs , context , args ): sign_tags = args . sign_tags tag_name = args . tag_name . format ( ** context ) tag_message = args . tag_message . format ( ** context ) do_tag = args . tag and not args . dry_run logger . info ( \" %s ' %s ' %s in %s and %s \" , \"Would tag\" if not do_tag else \"Tagging\" , tag_name , \"with message '{}'\" . format ( tag_message ) if tag_message else \"without message\" , vcs . __name__ , \"signing\" if sign_tags else \"not signing\" , ) if do_tag : vcs . tag ( sign_tags , tag_name , tag_message )","title":"Module bumpversion.cli"},{"location":"reference/bumpversion/cli/#variables","text":"DESCRIPTION OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES RE_DETECT_SECTION_TYPE VCS logger logger_list special_char_context time_context","title":"Variables"},{"location":"reference/bumpversion/cli/#functions","text":"","title":"Functions"},{"location":"reference/bumpversion/cli/#main","text":"def main ( original_args = None ) View Source def main ( original_args = None ) : # determine configuration based on command - line arguments # and on - disk configuration files args , known_args , root_parser , positionals = _parse_arguments_phase_1 ( original_args ) _setup_logging ( known_args . list , known_args . verbose ) vcs_info = _determine_vcs_usability () defaults = _determine_current_version ( vcs_info ) explicit_config = None if hasattr ( known_args , \" config_file \" ) : explicit_config = known_args . config_file config_file = _determine_config_file ( explicit_config ) config , config_file_exists , config_newlines , part_configs , files = _load_configuration ( config_file , explicit_config , defaults , ) known_args , parser2 , remaining_argv = _parse_arguments_phase_2 ( args , known_args , defaults , root_parser ) version_config = _setup_versionconfig ( known_args , part_configs ) current_version = version_config . parse ( known_args . current_version ) context = dict ( itertools . chain ( time_context . items () , prefixed_environ () . items () , vcs_info . items () , special_char_context . items () , ) ) # calculate the desired new version new_version = _assemble_new_version ( context , current_version , defaults , known_args . current_version , positionals , version_config ) args , file_names = _parse_arguments_phase_3 ( remaining_argv , positionals , defaults , parser2 ) new_version = _parse_new_version ( args , new_version , version_config ) # do not use the files from the config if args . no_configured_files : files = [] # replace version in target files vcs = _determine_vcs_dirty ( VCS , defaults ) files . extend ( ConfiguredFile ( file_name , version_config ) for file_name in ( file_names or positionals [ 1 :] ) ) _check_files_contain_version ( files , current_version , context ) _replace_version_in_files ( files , current_version , new_version , args . dry_run , context ) _log_list ( config , args . new_version ) # store the new version _update_config_file ( config , config_file , config_newlines , config_file_exists , args . new_version , args . dry_run , ) # commit and tag if vcs : context = _commit_to_vcs ( files , context , config_file , config_file_exists , vcs , args , current_version , new_version ) _tag_in_vcs ( vcs , context , args )","title":"main"},{"location":"reference/bumpversion/cli/#split_args_in_optional_and_positional","text":"def split_args_in_optional_and_positional ( args ) View Source def split_args_in_optional_and_positional ( args ) : # manually parsing positional arguments because stupid argparse can ' t mix # positional and optional arguments positions = [] for i , arg in enumerate ( args ) : previous = None if i > 0 : previous = args [ i - 1 ] if ( not arg . startswith ( \" - \" )) and ( previous not in OPTIONAL_ARGUMENTS_THAT_TAKE_VALUES ) : positions . append ( i ) positionals = [ arg for i , arg in enumerate ( args ) if i in positions ] args = [ arg for i , arg in enumerate ( args ) if i not in positions ] return ( positionals , args )","title":"split_args_in_optional_and_positional"},{"location":"reference/bumpversion/exceptions/","text":"Module bumpversion.exceptions View Source class BumpVersionException ( Exception ) : \"\"\" Custom base class for all BumpVersion exception types. \"\"\" class IncompleteVersionRepresentationException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class MissingValueForSerializationException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class WorkingDirectoryIsDirtyException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class MercurialDoesNotSupportSignedTagsException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class VersionNotFoundException ( BumpVersionException ) : \"\"\" A version number was not found in a source file. \"\"\" class InvalidVersionPartException ( BumpVersionException ) : \"\"\" The specified part (e.g. 'bugfix') was not found \"\"\" Classes BumpVersionException class BumpVersionException ( / , * args , ** kwargs ) Custom base class for all BumpVersion exception types. View Source class BumpVersionException ( Exception ) : \"\"\" Custom base class for all BumpVersion exception types. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants bumpversion.exceptions.IncompleteVersionRepresentationException bumpversion.exceptions.MissingValueForSerializationException bumpversion.exceptions.WorkingDirectoryIsDirtyException bumpversion.exceptions.MercurialDoesNotSupportSignedTagsException bumpversion.exceptions.VersionNotFoundException bumpversion.exceptions.InvalidVersionPartException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. IncompleteVersionRepresentationException class IncompleteVersionRepresentationException ( message ) Custom base class for all BumpVersion exception types. View Source class IncompleteVersionRepresentationException ( BumpVersionException ): def __init__ ( self , message ): self . message = message Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidVersionPartException class InvalidVersionPartException ( / , * args , ** kwargs ) The specified part (e.g. 'bugfix') was not found View Source class InvalidVersionPartException ( BumpVersionException ): \"\"\"The specified part (e.g. 'bugfix') was not found\"\"\" Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. MercurialDoesNotSupportSignedTagsException class MercurialDoesNotSupportSignedTagsException ( message ) Custom base class for all BumpVersion exception types. View Source class MercurialDoesNotSupportSignedTagsException ( BumpVersionException ): def __init__ ( self , message ): self . message = message Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. MissingValueForSerializationException class MissingValueForSerializationException ( message ) Custom base class for all BumpVersion exception types. View Source class MissingValueForSerializationException ( BumpVersionException ): def __init__ ( self , message ): self . message = message Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. VersionNotFoundException class VersionNotFoundException ( / , * args , ** kwargs ) A version number was not found in a source file. View Source class VersionNotFoundException ( BumpVersionException ): \"\"\"A version number was not found in a source file.\"\"\" Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. WorkingDirectoryIsDirtyException class WorkingDirectoryIsDirtyException ( message ) Custom base class for all BumpVersion exception types. View Source class WorkingDirectoryIsDirtyException ( BumpVersionException ): def __init__ ( self , message ): self . message = message Ancestors (in MRO) bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/bumpversion/exceptions/#module-bumpversionexceptions","text":"View Source class BumpVersionException ( Exception ) : \"\"\" Custom base class for all BumpVersion exception types. \"\"\" class IncompleteVersionRepresentationException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class MissingValueForSerializationException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class WorkingDirectoryIsDirtyException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class MercurialDoesNotSupportSignedTagsException ( BumpVersionException ) : def __init__ ( self , message ) : self . message = message class VersionNotFoundException ( BumpVersionException ) : \"\"\" A version number was not found in a source file. \"\"\" class InvalidVersionPartException ( BumpVersionException ) : \"\"\" The specified part (e.g. 'bugfix') was not found \"\"\"","title":"Module bumpversion.exceptions"},{"location":"reference/bumpversion/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/bumpversion/exceptions/#bumpversionexception","text":"class BumpVersionException ( / , * args , ** kwargs ) Custom base class for all BumpVersion exception types. View Source class BumpVersionException ( Exception ) : \"\"\" Custom base class for all BumpVersion exception types. \"\"\"","title":"BumpVersionException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#descendants","text":"bumpversion.exceptions.IncompleteVersionRepresentationException bumpversion.exceptions.MissingValueForSerializationException bumpversion.exceptions.WorkingDirectoryIsDirtyException bumpversion.exceptions.MercurialDoesNotSupportSignedTagsException bumpversion.exceptions.VersionNotFoundException bumpversion.exceptions.InvalidVersionPartException","title":"Descendants"},{"location":"reference/bumpversion/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#incompleteversionrepresentationexception","text":"class IncompleteVersionRepresentationException ( message ) Custom base class for all BumpVersion exception types. View Source class IncompleteVersionRepresentationException ( BumpVersionException ): def __init__ ( self , message ): self . message = message","title":"IncompleteVersionRepresentationException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_1","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#invalidversionpartexception","text":"class InvalidVersionPartException ( / , * args , ** kwargs ) The specified part (e.g. 'bugfix') was not found View Source class InvalidVersionPartException ( BumpVersionException ): \"\"\"The specified part (e.g. 'bugfix') was not found\"\"\"","title":"InvalidVersionPartException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_2","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#mercurialdoesnotsupportsignedtagsexception","text":"class MercurialDoesNotSupportSignedTagsException ( message ) Custom base class for all BumpVersion exception types. View Source class MercurialDoesNotSupportSignedTagsException ( BumpVersionException ): def __init__ ( self , message ): self . message = message","title":"MercurialDoesNotSupportSignedTagsException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_3","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#missingvalueforserializationexception","text":"class MissingValueForSerializationException ( message ) Custom base class for all BumpVersion exception types. View Source class MissingValueForSerializationException ( BumpVersionException ): def __init__ ( self , message ): self . message = message","title":"MissingValueForSerializationException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_4","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#versionnotfoundexception","text":"class VersionNotFoundException ( / , * args , ** kwargs ) A version number was not found in a source file. View Source class VersionNotFoundException ( BumpVersionException ): \"\"\"A version number was not found in a source file.\"\"\"","title":"VersionNotFoundException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_5","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_5","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_5","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/exceptions/#workingdirectoryisdirtyexception","text":"class WorkingDirectoryIsDirtyException ( message ) Custom base class for all BumpVersion exception types. View Source class WorkingDirectoryIsDirtyException ( BumpVersionException ): def __init__ ( self , message ): self . message = message","title":"WorkingDirectoryIsDirtyException"},{"location":"reference/bumpversion/exceptions/#ancestors-in-mro_6","text":"bumpversion.exceptions.BumpVersionException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/exceptions/#class-variables_6","text":"args","title":"Class variables"},{"location":"reference/bumpversion/exceptions/#methods_6","text":"","title":"Methods"},{"location":"reference/bumpversion/exceptions/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/bumpversion/functions/","text":"Module bumpversion.functions View Source import re class NumericFunction : \"\"\" This is a class that provides a numeric function for version parts. It simply starts with the provided first_value (0 by default) and increases it following the sequence of integer numbers. The optional value of this function is equal to the first value. This function also supports alphanumeric parts, altering just the numeric part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is considered (e.g. 'r3-001' --> 'r4-001'). \"\"\" FIRST_NUMERIC = re . compile ( r \"([^\\d]*)(\\d+)(.*)\" ) def __init__ ( self , first_value = None ): if first_value is not None : try : _ , _ , _ = self . FIRST_NUMERIC . search ( first_value ) . groups () except AttributeError : raise ValueError ( \"The given first value {} does not contain any digit\" . format ( first_value ) ) else : first_value = 0 self . first_value = str ( first_value ) self . optional_value = self . first_value def bump ( self , value ): part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ([ part_prefix , str ( bumped_numeric ), part_suffix ]) class ValuesFunction : \"\"\" This is a class that provides a values list based function for version parts. It is initialized with a list of values and iterates through them when bumping the part. The default optional value of this function is equal to the first value, but may be otherwise specified. When trying to bump a part which has already the maximum value in the list you get a ValueError exception. \"\"\" def __init__ ( self , values , optional_value = None , first_value = None ): if not values : raise ValueError ( \"Version part values cannot be empty\" ) self . _values = values if optional_value is None : optional_value = values [ 0 ] if optional_value not in values : raise ValueError ( \"Optional value {} must be included in values {}\" . format ( optional_value , values ) ) self . optional_value = optional_value if first_value is None : first_value = values [ 0 ] if first_value not in values : raise ValueError ( \"First value {} must be included in values {}\" . format ( first_value , values ) ) self . first_value = first_value def bump ( self , value ): try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \"The part has already the maximum value among {} and cannot be bumped.\" . format ( self . _values ) ) Classes NumericFunction class NumericFunction ( first_value = None ) This is a class that provides a numeric function for version parts. It simply starts with the provided first_value (0 by default) and increases it following the sequence of integer numbers. The optional value of this function is equal to the first value. This function also supports alphanumeric parts, altering just the numeric part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is considered (e.g. 'r3-001' --> 'r4-001'). View Source class NumericFunction : \"\"\" This is a class that provides a numeric function for version parts . It simply starts with the provided first_value ( 0 by default ) and increases it following the sequence of integer numbers . The optional value of this function is equal to the first value . This function also supports alphanumeric parts , altering just the numeric part ( e . g . ' r3 ' --> ' r4 ' ) . Only the first numeric group found in the part is considered ( e . g . ' r3-001 ' --> ' r4-001 ' ) . \"\"\" FIRST_NUMERIC = re . compile ( r \" ([^\\d]*)(\\d+)(.*) \" ) def __init__ ( self , first_value = None ) : if first_value is not None : try : _ , _ , _ = self . FIRST_NUMERIC . search ( first_value ) . groups () except AttributeError : raise ValueError ( \" The given first value {} does not contain any digit \" . format ( first_value ) ) else : first_value = 0 self . first_value = str ( first_value ) self . optional_value = self . first_value def bump ( self , value ) : part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ( [ part_prefix , str ( bumped_numeric ) , part_suffix ] ) Class variables FIRST_NUMERIC Methods bump def bump ( self , value ) View Source def bump ( self , value ) : part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ( [ part_prefix , str ( bumped_numeric ) , part_suffix ] ) ValuesFunction class ValuesFunction ( values , optional_value = None , first_value = None ) This is a class that provides a values list based function for version parts. It is initialized with a list of values and iterates through them when bumping the part. The default optional value of this function is equal to the first value, but may be otherwise specified. When trying to bump a part which has already the maximum value in the list you get a ValueError exception. View Source class ValuesFunction : \"\"\" This is a class that provides a values list based function for version parts . It is initialized with a list of values and iterates through them when bumping the part . The default optional value of this function is equal to the first value , but may be otherwise specified . When trying to bump a part which has already the maximum value in the list you get a ValueError exception . \"\"\" def __init__ ( self , values , optional_value = None , first_value = None ) : if not values : raise ValueError ( \" Version part values cannot be empty \" ) self . _values = values if optional_value is None : optional_value = values [ 0 ] if optional_value not in values : raise ValueError ( \" Optional value {} must be included in values {} \" . format ( optional_value , values ) ) self . optional_value = optional_value if first_value is None : first_value = values [ 0 ] if first_value not in values : raise ValueError ( \" First value {} must be included in values {} \" . format ( first_value , values ) ) self . first_value = first_value def bump ( self , value ) : try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \" The part has already the maximum value among {} and cannot be bumped. \" . format ( self . _values ) ) Methods bump def bump ( self , value ) View Source def bump ( self , value ) : try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \" The part has already the maximum value among {} and cannot be bumped. \" . format ( self . _values ) )","title":"Functions"},{"location":"reference/bumpversion/functions/#module-bumpversionfunctions","text":"View Source import re class NumericFunction : \"\"\" This is a class that provides a numeric function for version parts. It simply starts with the provided first_value (0 by default) and increases it following the sequence of integer numbers. The optional value of this function is equal to the first value. This function also supports alphanumeric parts, altering just the numeric part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is considered (e.g. 'r3-001' --> 'r4-001'). \"\"\" FIRST_NUMERIC = re . compile ( r \"([^\\d]*)(\\d+)(.*)\" ) def __init__ ( self , first_value = None ): if first_value is not None : try : _ , _ , _ = self . FIRST_NUMERIC . search ( first_value ) . groups () except AttributeError : raise ValueError ( \"The given first value {} does not contain any digit\" . format ( first_value ) ) else : first_value = 0 self . first_value = str ( first_value ) self . optional_value = self . first_value def bump ( self , value ): part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ([ part_prefix , str ( bumped_numeric ), part_suffix ]) class ValuesFunction : \"\"\" This is a class that provides a values list based function for version parts. It is initialized with a list of values and iterates through them when bumping the part. The default optional value of this function is equal to the first value, but may be otherwise specified. When trying to bump a part which has already the maximum value in the list you get a ValueError exception. \"\"\" def __init__ ( self , values , optional_value = None , first_value = None ): if not values : raise ValueError ( \"Version part values cannot be empty\" ) self . _values = values if optional_value is None : optional_value = values [ 0 ] if optional_value not in values : raise ValueError ( \"Optional value {} must be included in values {}\" . format ( optional_value , values ) ) self . optional_value = optional_value if first_value is None : first_value = values [ 0 ] if first_value not in values : raise ValueError ( \"First value {} must be included in values {}\" . format ( first_value , values ) ) self . first_value = first_value def bump ( self , value ): try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \"The part has already the maximum value among {} and cannot be bumped.\" . format ( self . _values ) )","title":"Module bumpversion.functions"},{"location":"reference/bumpversion/functions/#classes","text":"","title":"Classes"},{"location":"reference/bumpversion/functions/#numericfunction","text":"class NumericFunction ( first_value = None ) This is a class that provides a numeric function for version parts. It simply starts with the provided first_value (0 by default) and increases it following the sequence of integer numbers. The optional value of this function is equal to the first value. This function also supports alphanumeric parts, altering just the numeric part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is considered (e.g. 'r3-001' --> 'r4-001'). View Source class NumericFunction : \"\"\" This is a class that provides a numeric function for version parts . It simply starts with the provided first_value ( 0 by default ) and increases it following the sequence of integer numbers . The optional value of this function is equal to the first value . This function also supports alphanumeric parts , altering just the numeric part ( e . g . ' r3 ' --> ' r4 ' ) . Only the first numeric group found in the part is considered ( e . g . ' r3-001 ' --> ' r4-001 ' ) . \"\"\" FIRST_NUMERIC = re . compile ( r \" ([^\\d]*)(\\d+)(.*) \" ) def __init__ ( self , first_value = None ) : if first_value is not None : try : _ , _ , _ = self . FIRST_NUMERIC . search ( first_value ) . groups () except AttributeError : raise ValueError ( \" The given first value {} does not contain any digit \" . format ( first_value ) ) else : first_value = 0 self . first_value = str ( first_value ) self . optional_value = self . first_value def bump ( self , value ) : part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ( [ part_prefix , str ( bumped_numeric ) , part_suffix ] )","title":"NumericFunction"},{"location":"reference/bumpversion/functions/#class-variables","text":"FIRST_NUMERIC","title":"Class variables"},{"location":"reference/bumpversion/functions/#methods","text":"","title":"Methods"},{"location":"reference/bumpversion/functions/#bump","text":"def bump ( self , value ) View Source def bump ( self , value ) : part_prefix , part_numeric , part_suffix = self . FIRST_NUMERIC . search ( value ) . groups () bumped_numeric = int ( part_numeric ) + 1 return \"\" . join ( [ part_prefix , str ( bumped_numeric ) , part_suffix ] )","title":"bump"},{"location":"reference/bumpversion/functions/#valuesfunction","text":"class ValuesFunction ( values , optional_value = None , first_value = None ) This is a class that provides a values list based function for version parts. It is initialized with a list of values and iterates through them when bumping the part. The default optional value of this function is equal to the first value, but may be otherwise specified. When trying to bump a part which has already the maximum value in the list you get a ValueError exception. View Source class ValuesFunction : \"\"\" This is a class that provides a values list based function for version parts . It is initialized with a list of values and iterates through them when bumping the part . The default optional value of this function is equal to the first value , but may be otherwise specified . When trying to bump a part which has already the maximum value in the list you get a ValueError exception . \"\"\" def __init__ ( self , values , optional_value = None , first_value = None ) : if not values : raise ValueError ( \" Version part values cannot be empty \" ) self . _values = values if optional_value is None : optional_value = values [ 0 ] if optional_value not in values : raise ValueError ( \" Optional value {} must be included in values {} \" . format ( optional_value , values ) ) self . optional_value = optional_value if first_value is None : first_value = values [ 0 ] if first_value not in values : raise ValueError ( \" First value {} must be included in values {} \" . format ( first_value , values ) ) self . first_value = first_value def bump ( self , value ) : try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \" The part has already the maximum value among {} and cannot be bumped. \" . format ( self . _values ) )","title":"ValuesFunction"},{"location":"reference/bumpversion/functions/#methods_1","text":"","title":"Methods"},{"location":"reference/bumpversion/functions/#bump_1","text":"def bump ( self , value ) View Source def bump ( self , value ) : try : return self . _values [ self . _values . index ( value ) + 1 ] except IndexError : raise ValueError ( \" The part has already the maximum value among {} and cannot be bumped. \" . format ( self . _values ) )","title":"bump"},{"location":"reference/bumpversion/utils/","text":"Module bumpversion.utils View Source from argparse import _ AppendAction from difflib import unified_diff import io import logging import os from bumpversion . exceptions import VersionNotFoundException logger = logging . getLogger ( __ name__ ) class DiscardDefaultIfSpecifiedAppendAction ( _ AppendAction ) : \"\"\" Fixes bug http://bugs.python.org/issue16399 for 'append' action \"\"\" def __ call__ ( self , parser , namespace , values , option_string = None ) : if getattr ( self , \"_discarded_default\" , None ) is None : setattr ( namespace , self . dest , []) self . _ discarded_default = True # pylint : disable = attribute - defined - outside - init super (). __ call__ ( parser , namespace , values , option_string = None ) def keyvaluestring ( d ) : return \", \" . join ( \"{}={}\" . format ( k , v ) for k , v in sorted ( d . items ())) def prefixed_environ () : return { \"${}\" . format ( key ) : value for key , value in os . environ . items ()} class ConfiguredFile : def __ init__ ( self , path , versionconfig ) : self . path = path self . _ versionconfig = versionconfig def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. \"\"\" context [ \"current_version\" ] = self . _ versionconfig . serialize ( version , context ) search_expression = self . _ versionconfig . search . format ( **context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn't customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self._versionconfig.search == \"{current_version}\" if search_pattern_is_default and self.contains(version.original): # original version is present and we're not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \"Did not find '{}' in file: '{}'\" . format ( search_expression , self . path ) ) def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \"current_version\" ] = self . _ versionconfig . serialize ( current_version , context ) context [ \"new_version\" ] = self . _ versionconfig . serialize ( new_version , context ) search_for = self . _ versionconfig . search . format ( **context ) replace_with = self . _ versionconfig . replace . format ( **context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after: # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before ! = file_content_after: logger . info ( \"%s file %s:\" , \"Would change\" if dry_run else \"Changing\" , self . path ) logger . info ( \"\\n\" . join ( list ( unified_diff ( file_content_before . splitlines (), file_content_after . splitlines (), lineterm= \"\" , fromfile= \"a/\" + self . path , tofile= \"b/\" + self . path , ) ) ) ) else : logger . info ( \"%s file %s\" , \"Would not change\" if dry_run else \"Not changing\" , self . path ) if not dry_run: with open ( self . path , \"wt\" , encoding= \"utf-8\" , newline = file_new_lines ) as f : f . write ( file_content_after ) def __ str__ ( self ) : return self . path def __ repr__ ( self ) : return \"<bumpversion.ConfiguredFile:{}>\" . format ( self . path ) Variables logger Functions keyvaluestring def keyvaluestring ( d ) View Source def keyvaluestring ( d ) : return \" , \" . join ( \" {}={} \" . format ( k , v ) for k , v in sorted ( d . items ())) prefixed_environ def prefixed_environ ( ) View Source def prefixed_environ () : return { \" ${} \" . format ( key ) : value for key , value in os . environ . items () } Classes ConfiguredFile class ConfiguredFile ( path , versionconfig ) View Source class ConfiguredFile : def __ init__ ( self , path , versionconfig ) : self . path = path self . _ versionconfig = versionconfig def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. \"\"\" context [ \"current_version\" ] = self . _ versionconfig . serialize ( version , context ) search_expression = self . _ versionconfig . search . format ( **context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn't customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self._versionconfig.search == \"{current_version}\" if search_pattern_is_default and self.contains(version.original): # original version is present and we're not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \"Did not find '{}' in file: '{}'\" . format ( search_expression , self . path ) ) def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \"current_version\" ] = self . _ versionconfig . serialize ( current_version , context ) context [ \"new_version\" ] = self . _ versionconfig . serialize ( new_version , context ) search_for = self . _ versionconfig . search . format ( **context ) replace_with = self . _ versionconfig . replace . format ( **context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after: # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before ! = file_content_after: logger . info ( \"%s file %s:\" , \"Would change\" if dry_run else \"Changing\" , self . path ) logger . info ( \"\\n\" . join ( list ( unified_diff ( file_content_before . splitlines (), file_content_after . splitlines (), lineterm= \"\" , fromfile= \"a/\" + self . path , tofile= \"b/\" + self . path , ) ) ) ) else : logger . info ( \"%s file %s\" , \"Would not change\" if dry_run else \"Not changing\" , self . path ) if not dry_run: with open ( self . path , \"wt\" , encoding= \"utf-8\" , newline = file_new_lines ) as f : f . write ( file_content_after ) def __ str__ ( self ) : return self . path def __ repr__ ( self ) : return \"<bumpversion.ConfiguredFile:{}>\" . format ( self . path ) Methods contains def contains ( self , search ) View Source def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False replace def replace ( self , current_version , new_version , context , dry_run ) View Source def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \" rt \" , encoding = \" utf-8 \" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \" current_version \" ] = self . _versionconfig . serialize ( current_version , context ) context [ \" new_version \" ] = self . _versionconfig . serialize ( new_version , context ) search_for = self . _versionconfig . search . format ( ** context ) replace_with = self . _versionconfig . replace . format ( ** context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after : # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before != file_content_after : logger . info ( \" %s file %s: \" , \" Would change \" if dry_run else \" Changing \" , self . path ) logger . info ( \" \\n \" . join ( list ( unified_diff ( file_content_before . splitlines () , file_content_after . splitlines () , lineterm = \"\" , fromfile = \" a/ \" + self . path , tofile = \" b/ \" + self . path , ) ) ) ) else : logger . info ( \" %s file %s \" , \" Would not change \" if dry_run else \" Not changing \" , self . path ) if not dry_run : with open ( self . path , \" wt \" , encoding = \" utf-8 \" , newline = file_new_lines ) as f : f . write ( file_content_after ) should_contain_version def should_contain_version ( self , version , context ) Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. View Source def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn ' t present in this file. Return normally if the version number is in fact present . \"\"\" context [ \" current_version \" ] = self . _versionconfig . serialize ( version , context ) search_expression = self . _versionconfig . search . format ( ** context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn ' t customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self . _versionconfig . search == \" {current_version} \" if search_pattern_is_default and self . contains ( version . original ) : # original version is present and we ' re not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \" Did not find '{}' in file: '{}' \" . format ( search_expression , self . path ) ) DiscardDefaultIfSpecifiedAppendAction class DiscardDefaultIfSpecifiedAppendAction ( option_strings , dest , nargs = None , const = None , default = None , type = None , choices = None , required = False , help = None , metavar = None ) Fixes bug http://bugs.python.org/issue16399 for 'append' action View Source class DiscardDefaultIfSpecifiedAppendAction ( _AppendAction ) : \"\"\" Fixes bug http : // bugs . python . org / issue16399 for ' append ' action \"\"\" def __call__ ( self , parser , namespace , values , option_string = None ) : if getattr ( self , \" _discarded_default \" , None ) is None : setattr ( namespace , self . dest , [] ) self . _discarded_default = True # pylint : disable = attribute - defined - outside - init super () . __call__ ( parser , namespace , values , option_string = None ) Ancestors (in MRO) argparse._AppendAction argparse.Action argparse._AttributeHolder","title":"Utils"},{"location":"reference/bumpversion/utils/#module-bumpversionutils","text":"View Source from argparse import _ AppendAction from difflib import unified_diff import io import logging import os from bumpversion . exceptions import VersionNotFoundException logger = logging . getLogger ( __ name__ ) class DiscardDefaultIfSpecifiedAppendAction ( _ AppendAction ) : \"\"\" Fixes bug http://bugs.python.org/issue16399 for 'append' action \"\"\" def __ call__ ( self , parser , namespace , values , option_string = None ) : if getattr ( self , \"_discarded_default\" , None ) is None : setattr ( namespace , self . dest , []) self . _ discarded_default = True # pylint : disable = attribute - defined - outside - init super (). __ call__ ( parser , namespace , values , option_string = None ) def keyvaluestring ( d ) : return \", \" . join ( \"{}={}\" . format ( k , v ) for k , v in sorted ( d . items ())) def prefixed_environ () : return { \"${}\" . format ( key ) : value for key , value in os . environ . items ()} class ConfiguredFile : def __ init__ ( self , path , versionconfig ) : self . path = path self . _ versionconfig = versionconfig def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. \"\"\" context [ \"current_version\" ] = self . _ versionconfig . serialize ( version , context ) search_expression = self . _ versionconfig . search . format ( **context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn't customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self._versionconfig.search == \"{current_version}\" if search_pattern_is_default and self.contains(version.original): # original version is present and we're not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \"Did not find '{}' in file: '{}'\" . format ( search_expression , self . path ) ) def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \"current_version\" ] = self . _ versionconfig . serialize ( current_version , context ) context [ \"new_version\" ] = self . _ versionconfig . serialize ( new_version , context ) search_for = self . _ versionconfig . search . format ( **context ) replace_with = self . _ versionconfig . replace . format ( **context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after: # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before ! = file_content_after: logger . info ( \"%s file %s:\" , \"Would change\" if dry_run else \"Changing\" , self . path ) logger . info ( \"\\n\" . join ( list ( unified_diff ( file_content_before . splitlines (), file_content_after . splitlines (), lineterm= \"\" , fromfile= \"a/\" + self . path , tofile= \"b/\" + self . path , ) ) ) ) else : logger . info ( \"%s file %s\" , \"Would not change\" if dry_run else \"Not changing\" , self . path ) if not dry_run: with open ( self . path , \"wt\" , encoding= \"utf-8\" , newline = file_new_lines ) as f : f . write ( file_content_after ) def __ str__ ( self ) : return self . path def __ repr__ ( self ) : return \"<bumpversion.ConfiguredFile:{}>\" . format ( self . path )","title":"Module bumpversion.utils"},{"location":"reference/bumpversion/utils/#variables","text":"logger","title":"Variables"},{"location":"reference/bumpversion/utils/#functions","text":"","title":"Functions"},{"location":"reference/bumpversion/utils/#keyvaluestring","text":"def keyvaluestring ( d ) View Source def keyvaluestring ( d ) : return \" , \" . join ( \" {}={} \" . format ( k , v ) for k , v in sorted ( d . items ()))","title":"keyvaluestring"},{"location":"reference/bumpversion/utils/#prefixed_environ","text":"def prefixed_environ ( ) View Source def prefixed_environ () : return { \" ${} \" . format ( key ) : value for key , value in os . environ . items () }","title":"prefixed_environ"},{"location":"reference/bumpversion/utils/#classes","text":"","title":"Classes"},{"location":"reference/bumpversion/utils/#configuredfile","text":"class ConfiguredFile ( path , versionconfig ) View Source class ConfiguredFile : def __ init__ ( self , path , versionconfig ) : self . path = path self . _ versionconfig = versionconfig def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. \"\"\" context [ \"current_version\" ] = self . _ versionconfig . serialize ( version , context ) search_expression = self . _ versionconfig . search . format ( **context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn't customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self._versionconfig.search == \"{current_version}\" if search_pattern_is_default and self.contains(version.original): # original version is present and we're not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \"Did not find '{}' in file: '{}'\" . format ( search_expression , self . path ) ) def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \"current_version\" ] = self . _ versionconfig . serialize ( current_version , context ) context [ \"new_version\" ] = self . _ versionconfig . serialize ( new_version , context ) search_for = self . _ versionconfig . search . format ( **context ) replace_with = self . _ versionconfig . replace . format ( **context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after: # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before ! = file_content_after: logger . info ( \"%s file %s:\" , \"Would change\" if dry_run else \"Changing\" , self . path ) logger . info ( \"\\n\" . join ( list ( unified_diff ( file_content_before . splitlines (), file_content_after . splitlines (), lineterm= \"\" , fromfile= \"a/\" + self . path , tofile= \"b/\" + self . path , ) ) ) ) else : logger . info ( \"%s file %s\" , \"Would not change\" if dry_run else \"Not changing\" , self . path ) if not dry_run: with open ( self . path , \"wt\" , encoding= \"utf-8\" , newline = file_new_lines ) as f : f . write ( file_content_after ) def __ str__ ( self ) : return self . path def __ repr__ ( self ) : return \"<bumpversion.ConfiguredFile:{}>\" . format ( self . path )","title":"ConfiguredFile"},{"location":"reference/bumpversion/utils/#methods","text":"","title":"Methods"},{"location":"reference/bumpversion/utils/#contains","text":"def contains ( self , search ) View Source def contains ( self , search ) : if not search : return False with open ( self . path , \"rt\" , encoding= \"utf-8\" ) as f : search_lines = search . splitlines () lookbehind = [] for lineno , line in enumerate ( f . readlines ()) : lookbehind . append ( line . rstrip ( \"\\n\" )) if len ( lookbehind ) > len ( search_lines ) : lookbehind = lookbehind [ 1 : ] if ( search_lines [ 0 ] in lookbehind [ 0 ] and search_lines [ - 1 ] in lookbehind [ - 1 ] and search_lines [ 1 :- 1 ] == lookbehind [ 1 :- 1 ] ) : logger . info ( \"Found '%s' in %s at line %s: %s\" , search , self . path , lineno - ( len ( lookbehind ) - 1 ), line . rstrip (), ) return True return False","title":"contains"},{"location":"reference/bumpversion/utils/#replace","text":"def replace ( self , current_version , new_version , context , dry_run ) View Source def replace ( self , current_version , new_version , context , dry_run ) : with open ( self . path , \" rt \" , encoding = \" utf-8 \" ) as f : file_content_before = f . read () file_new_lines = f . newlines context [ \" current_version \" ] = self . _versionconfig . serialize ( current_version , context ) context [ \" new_version \" ] = self . _versionconfig . serialize ( new_version , context ) search_for = self . _versionconfig . search . format ( ** context ) replace_with = self . _versionconfig . replace . format ( ** context ) file_content_after = file_content_before . replace ( search_for , replace_with ) if file_content_before == file_content_after : # TODO expose this to be configurable file_content_after = file_content_before . replace ( current_version . original , replace_with ) if file_content_before != file_content_after : logger . info ( \" %s file %s: \" , \" Would change \" if dry_run else \" Changing \" , self . path ) logger . info ( \" \\n \" . join ( list ( unified_diff ( file_content_before . splitlines () , file_content_after . splitlines () , lineterm = \"\" , fromfile = \" a/ \" + self . path , tofile = \" b/ \" + self . path , ) ) ) ) else : logger . info ( \" %s file %s \" , \" Would not change \" if dry_run else \" Not changing \" , self . path ) if not dry_run : with open ( self . path , \" wt \" , encoding = \" utf-8 \" , newline = file_new_lines ) as f : f . write ( file_content_after )","title":"replace"},{"location":"reference/bumpversion/utils/#should_contain_version","text":"def should_contain_version ( self , version , context ) Raise VersionNotFound if the version number isn't present in this file. Return normally if the version number is in fact present. View Source def should_contain_version ( self , version , context ) : \"\"\" Raise VersionNotFound if the version number isn ' t present in this file. Return normally if the version number is in fact present . \"\"\" context [ \" current_version \" ] = self . _versionconfig . serialize ( version , context ) search_expression = self . _versionconfig . search . format ( ** context ) if self . contains ( search_expression ) : return # the ` search ` pattern did not match , but the original supplied # version number ( representing the same version part values ) might # match instead . # check whether ` search ` isn ' t customized, i.e. should match only # very specific parts of the file search_pattern_is_default = self . _versionconfig . search == \" {current_version} \" if search_pattern_is_default and self . contains ( version . original ) : # original version is present and we ' re not looking for something # more specific -> this is accepted as a match return # version not found raise VersionNotFoundException ( \" Did not find '{}' in file: '{}' \" . format ( search_expression , self . path ) )","title":"should_contain_version"},{"location":"reference/bumpversion/utils/#discarddefaultifspecifiedappendaction","text":"class DiscardDefaultIfSpecifiedAppendAction ( option_strings , dest , nargs = None , const = None , default = None , type = None , choices = None , required = False , help = None , metavar = None ) Fixes bug http://bugs.python.org/issue16399 for 'append' action View Source class DiscardDefaultIfSpecifiedAppendAction ( _AppendAction ) : \"\"\" Fixes bug http : // bugs . python . org / issue16399 for ' append ' action \"\"\" def __call__ ( self , parser , namespace , values , option_string = None ) : if getattr ( self , \" _discarded_default \" , None ) is None : setattr ( namespace , self . dest , [] ) self . _discarded_default = True # pylint : disable = attribute - defined - outside - init super () . __call__ ( parser , namespace , values , option_string = None )","title":"DiscardDefaultIfSpecifiedAppendAction"},{"location":"reference/bumpversion/utils/#ancestors-in-mro","text":"argparse._AppendAction argparse.Action argparse._AttributeHolder","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/vcs/","text":"Module bumpversion.vcs View Source import errno import logging import os import subprocess from tempfile import NamedTemporaryFile from bumpversion.exceptions import ( WorkingDirectoryIsDirtyException , MercurialDoesNotSupportSignedTagsException , ) logger = logging . getLogger ( __name__ ) class BaseVCS : _TEST_USABLE_COMMAND = None _COMMIT_COMMAND = None @classmethod def commit ( cls , message , context , extra_args = None ): extra_args = extra_args or [] with NamedTemporaryFile ( \"wb\" , delete = False ) as f : f . write ( message . encode ( \"utf-8\" )) env = os . environ . copy () env [ \"HGENCODING\" ] = \"utf-8\" for key in ( \"current_version\" , \"new_version\" ): env [ str ( \"BUMPVERSION_\" + key . upper ())] = str ( context [ key ]) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \"Failed to run {}: return code {}, output: {}\" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) @classmethod def is_usable ( cls ): try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ): return False raise class Git ( BaseVCS ): _TEST_USABLE_COMMAND = [ \"git\" , \"rev-parse\" , \"--git-dir\" ] _COMMIT_COMMAND = [ \"git\" , \"commit\" , \"-F\" ] @classmethod def assert_nondirty ( cls ): lines = [ line . strip () for line in subprocess . check_output ( [ \"git\" , \"status\" , \"--porcelain\" ] ) . splitlines () if not line . strip () . startswith ( b \"??\" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \"Git working directory is not clean: \\n {}\" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @classmethod def latest_tag_info ( cls ): try : # git-describe doesn't update the git-index, so we do that subprocess . check_output ([ \"git\" , \"update-index\" , \"--refresh\" ]) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \"git\" , \"describe\" , \"--dirty\" , \"--tags\" , \"--long\" , \"--abbrev=40\" , \"--match=v*\" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \"-\" ) ) except subprocess . CalledProcessError : logger . debug ( \"Error when running git describe\" ) return {} info = {} if describe_out [ - 1 ] . strip () == \"dirty\" : info [ \"dirty\" ] = True describe_out . pop () info [ \"commit_sha\" ] = describe_out . pop () . lstrip ( \"g\" ) info [ \"distance_to_latest_tag\" ] = int ( describe_out . pop ()) info [ \"current_version\" ] = \"-\" . join ( describe_out ) . lstrip ( \"v\" ) return info @classmethod def add_path ( cls , path ): subprocess . check_output ([ \"git\" , \"add\" , \"--update\" , path ]) @classmethod def tag ( cls , sign , name , message ): \"\"\" Create a tag of the new_version in VCS. If only name is given, bumpversion uses a lightweight tag. Otherwise, it utilizes an annotated tag. \"\"\" command = [ \"git\" , \"tag\" , name ] if sign : command += [ \"--sign\" ] if message : command += [ \"--message\" , message ] subprocess . check_output ( command ) class Mercurial ( BaseVCS ): _TEST_USABLE_COMMAND = [ \"hg\" , \"root\" ] _COMMIT_COMMAND = [ \"hg\" , \"commit\" , \"--logfile\" ] @classmethod def latest_tag_info ( cls ): return {} @classmethod def assert_nondirty ( cls ): lines = [ line . strip () for line in subprocess . check_output ([ \"hg\" , \"status\" , \"-mard\" ]) . splitlines () if not line . strip () . startswith ( b \"??\" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \"Mercurial working directory is not clean: \\n {}\" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @classmethod def add_path ( cls , path ): pass @classmethod def tag ( cls , sign , name , message ): command = [ \"hg\" , \"tag\" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \"Mercurial does not support signed tags.\" ) if message : command += [ \"--message\" , message ] subprocess . check_output ( command ) Variables logger Classes BaseVCS class BaseVCS ( / , * args , ** kwargs ) View Source class BaseVCS : _TEST_USABLE_COMMAND = None _COMMIT_COMMAND = None @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise Descendants bumpversion.vcs.Git bumpversion.vcs.Mercurial Static methods commit def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) is_usable def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise Git class Git ( / , * args , ** kwargs ) View Source class Git ( BaseVCS ) : _TEST_USABLE_COMMAND = [ \" git \" , \" rev-parse \" , \" --git-dir \" ] _COMMIT_COMMAND = [ \" git \" , \" commit \" , \" -F \" ] @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" git \" , \" status \" , \" --porcelain \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Git working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @ classmethod def latest_tag_info ( cls ) : try : # git - describe doesn ' t update the git-index, so we do that subprocess . check_output ( [ \" git \" , \" update-index \" , \" --refresh \" ] ) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \" git \" , \" describe \" , \" --dirty \" , \" --tags \" , \" --long \" , \" --abbrev=40 \" , \" --match=v* \" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \" - \" ) ) except subprocess . CalledProcessError : logger . debug ( \" Error when running git describe \" ) return {} info = {} if describe_out [ - 1 ]. strip () == \" dirty \" : info [ \" dirty \" ] = True describe_out . pop () info [ \" commit_sha \" ] = describe_out . pop () . lstrip ( \" g \" ) info [ \" distance_to_latest_tag \" ] = int ( describe_out . pop ()) info [ \" current_version \" ] = \" - \" . join ( describe_out ) . lstrip ( \" v \" ) return info @ classmethod def add_path ( cls , path ) : subprocess . check_output ( [ \" git \" , \" add \" , \" --update \" , path ] ) @ classmethod def tag ( cls , sign , name , message ) : \"\"\" Create a tag of the new_version in VCS . If only name is given , bumpversion uses a lightweight tag . Otherwise , it utilizes an annotated tag . \"\"\" command = [ \" git \" , \" tag \" , name ] if sign : command += [ \" --sign \" ] if message : command += [ \" --message \" , message ] subprocess . check_output ( command ) Ancestors (in MRO) bumpversion.vcs.BaseVCS Static methods add_path def add_path ( path ) View Source @classmethod def add_path ( cls , path ) : subprocess . check_output ( [ \"git\", \"add\", \"--update\", path ] ) assert_nondirty def assert_nondirty ( ) View Source @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" git \" , \" status \" , \" --porcelain \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Git working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) commit def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) is_usable def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise latest_tag_info def latest_tag_info ( ) View Source @ classmethod def latest_tag_info ( cls ) : try : # git - describe doesn ' t update the git-index, so we do that subprocess . check_output ( [ \" git \" , \" update-index \" , \" --refresh \" ] ) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \" git \" , \" describe \" , \" --dirty \" , \" --tags \" , \" --long \" , \" --abbrev=40 \" , \" --match=v* \" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \" - \" ) ) except subprocess . CalledProcessError : logger . debug ( \" Error when running git describe \" ) return {} info = {} if describe_out [ - 1 ]. strip () == \" dirty \" : info [ \" dirty \" ] = True describe_out . pop () info [ \" commit_sha \" ] = describe_out . pop () . lstrip ( \" g \" ) info [ \" distance_to_latest_tag \" ] = int ( describe_out . pop ()) info [ \" current_version \" ] = \" - \" . join ( describe_out ) . lstrip ( \" v \" ) return info tag def tag ( sign , name , message ) Create a tag of the new_version in VCS. If only name is given, bumpversion uses a lightweight tag. Otherwise, it utilizes an annotated tag. View Source @ classmethod def tag ( cls , sign , name , message ) : \"\"\" Create a tag of the new_version in VCS . If only name is given , bumpversion uses a lightweight tag . Otherwise , it utilizes an annotated tag . \"\"\" command = [ \" git \" , \" tag \" , name ] if sign : command += [ \" --sign \" ] if message : command += [ \" --message \" , message ] subprocess . check_output ( command ) Mercurial class Mercurial ( / , * args , ** kwargs ) View Source class Mercurial ( BaseVCS ) : _TEST_USABLE_COMMAND = [ \" hg \" , \" root \" ] _COMMIT_COMMAND = [ \" hg \" , \" commit \" , \" --logfile \" ] @ classmethod def latest_tag_info ( cls ) : return {} @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" hg \" , \" status \" , \" -mard \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Mercurial working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @ classmethod def add_path ( cls , path ) : pass @ classmethod def tag ( cls , sign , name , message ) : command = [ \" hg \" , \" tag \" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \" Mercurial does not support signed tags. \" ) if message : command += [ \" --message \" , message ] subprocess . check_output ( command ) Ancestors (in MRO) bumpversion.vcs.BaseVCS Static methods add_path def add_path ( path ) View Source @classmethod def add_path ( cls , path ) : pass assert_nondirty def assert_nondirty ( ) View Source @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" hg \" , \" status \" , \" -mard \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Mercurial working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) commit def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) is_usable def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise latest_tag_info def latest_tag_info ( ) View Source @ classmethod def latest_tag_info ( cls ) : return {} tag def tag ( sign , name , message ) View Source @ classmethod def tag ( cls , sign , name , message ) : command = [ \" hg \" , \" tag \" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \" Mercurial does not support signed tags. \" ) if message : command += [ \" --message \" , message ] subprocess . check_output ( command )","title":"Vcs"},{"location":"reference/bumpversion/vcs/#module-bumpversionvcs","text":"View Source import errno import logging import os import subprocess from tempfile import NamedTemporaryFile from bumpversion.exceptions import ( WorkingDirectoryIsDirtyException , MercurialDoesNotSupportSignedTagsException , ) logger = logging . getLogger ( __name__ ) class BaseVCS : _TEST_USABLE_COMMAND = None _COMMIT_COMMAND = None @classmethod def commit ( cls , message , context , extra_args = None ): extra_args = extra_args or [] with NamedTemporaryFile ( \"wb\" , delete = False ) as f : f . write ( message . encode ( \"utf-8\" )) env = os . environ . copy () env [ \"HGENCODING\" ] = \"utf-8\" for key in ( \"current_version\" , \"new_version\" ): env [ str ( \"BUMPVERSION_\" + key . upper ())] = str ( context [ key ]) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \"Failed to run {}: return code {}, output: {}\" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) @classmethod def is_usable ( cls ): try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ): return False raise class Git ( BaseVCS ): _TEST_USABLE_COMMAND = [ \"git\" , \"rev-parse\" , \"--git-dir\" ] _COMMIT_COMMAND = [ \"git\" , \"commit\" , \"-F\" ] @classmethod def assert_nondirty ( cls ): lines = [ line . strip () for line in subprocess . check_output ( [ \"git\" , \"status\" , \"--porcelain\" ] ) . splitlines () if not line . strip () . startswith ( b \"??\" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \"Git working directory is not clean: \\n {}\" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @classmethod def latest_tag_info ( cls ): try : # git-describe doesn't update the git-index, so we do that subprocess . check_output ([ \"git\" , \"update-index\" , \"--refresh\" ]) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \"git\" , \"describe\" , \"--dirty\" , \"--tags\" , \"--long\" , \"--abbrev=40\" , \"--match=v*\" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \"-\" ) ) except subprocess . CalledProcessError : logger . debug ( \"Error when running git describe\" ) return {} info = {} if describe_out [ - 1 ] . strip () == \"dirty\" : info [ \"dirty\" ] = True describe_out . pop () info [ \"commit_sha\" ] = describe_out . pop () . lstrip ( \"g\" ) info [ \"distance_to_latest_tag\" ] = int ( describe_out . pop ()) info [ \"current_version\" ] = \"-\" . join ( describe_out ) . lstrip ( \"v\" ) return info @classmethod def add_path ( cls , path ): subprocess . check_output ([ \"git\" , \"add\" , \"--update\" , path ]) @classmethod def tag ( cls , sign , name , message ): \"\"\" Create a tag of the new_version in VCS. If only name is given, bumpversion uses a lightweight tag. Otherwise, it utilizes an annotated tag. \"\"\" command = [ \"git\" , \"tag\" , name ] if sign : command += [ \"--sign\" ] if message : command += [ \"--message\" , message ] subprocess . check_output ( command ) class Mercurial ( BaseVCS ): _TEST_USABLE_COMMAND = [ \"hg\" , \"root\" ] _COMMIT_COMMAND = [ \"hg\" , \"commit\" , \"--logfile\" ] @classmethod def latest_tag_info ( cls ): return {} @classmethod def assert_nondirty ( cls ): lines = [ line . strip () for line in subprocess . check_output ([ \"hg\" , \"status\" , \"-mard\" ]) . splitlines () if not line . strip () . startswith ( b \"??\" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \"Mercurial working directory is not clean: \\n {}\" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @classmethod def add_path ( cls , path ): pass @classmethod def tag ( cls , sign , name , message ): command = [ \"hg\" , \"tag\" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \"Mercurial does not support signed tags.\" ) if message : command += [ \"--message\" , message ] subprocess . check_output ( command )","title":"Module bumpversion.vcs"},{"location":"reference/bumpversion/vcs/#variables","text":"logger","title":"Variables"},{"location":"reference/bumpversion/vcs/#classes","text":"","title":"Classes"},{"location":"reference/bumpversion/vcs/#basevcs","text":"class BaseVCS ( / , * args , ** kwargs ) View Source class BaseVCS : _TEST_USABLE_COMMAND = None _COMMIT_COMMAND = None @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name ) @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise","title":"BaseVCS"},{"location":"reference/bumpversion/vcs/#descendants","text":"bumpversion.vcs.Git bumpversion.vcs.Mercurial","title":"Descendants"},{"location":"reference/bumpversion/vcs/#static-methods","text":"","title":"Static methods"},{"location":"reference/bumpversion/vcs/#commit","text":"def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name )","title":"commit"},{"location":"reference/bumpversion/vcs/#is_usable","text":"def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise","title":"is_usable"},{"location":"reference/bumpversion/vcs/#git","text":"class Git ( / , * args , ** kwargs ) View Source class Git ( BaseVCS ) : _TEST_USABLE_COMMAND = [ \" git \" , \" rev-parse \" , \" --git-dir \" ] _COMMIT_COMMAND = [ \" git \" , \" commit \" , \" -F \" ] @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" git \" , \" status \" , \" --porcelain \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Git working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @ classmethod def latest_tag_info ( cls ) : try : # git - describe doesn ' t update the git-index, so we do that subprocess . check_output ( [ \" git \" , \" update-index \" , \" --refresh \" ] ) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \" git \" , \" describe \" , \" --dirty \" , \" --tags \" , \" --long \" , \" --abbrev=40 \" , \" --match=v* \" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \" - \" ) ) except subprocess . CalledProcessError : logger . debug ( \" Error when running git describe \" ) return {} info = {} if describe_out [ - 1 ]. strip () == \" dirty \" : info [ \" dirty \" ] = True describe_out . pop () info [ \" commit_sha \" ] = describe_out . pop () . lstrip ( \" g \" ) info [ \" distance_to_latest_tag \" ] = int ( describe_out . pop ()) info [ \" current_version \" ] = \" - \" . join ( describe_out ) . lstrip ( \" v \" ) return info @ classmethod def add_path ( cls , path ) : subprocess . check_output ( [ \" git \" , \" add \" , \" --update \" , path ] ) @ classmethod def tag ( cls , sign , name , message ) : \"\"\" Create a tag of the new_version in VCS . If only name is given , bumpversion uses a lightweight tag . Otherwise , it utilizes an annotated tag . \"\"\" command = [ \" git \" , \" tag \" , name ] if sign : command += [ \" --sign \" ] if message : command += [ \" --message \" , message ] subprocess . check_output ( command )","title":"Git"},{"location":"reference/bumpversion/vcs/#ancestors-in-mro","text":"bumpversion.vcs.BaseVCS","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/vcs/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/bumpversion/vcs/#add_path","text":"def add_path ( path ) View Source @classmethod def add_path ( cls , path ) : subprocess . check_output ( [ \"git\", \"add\", \"--update\", path ] )","title":"add_path"},{"location":"reference/bumpversion/vcs/#assert_nondirty","text":"def assert_nondirty ( ) View Source @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" git \" , \" status \" , \" --porcelain \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Git working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) )","title":"assert_nondirty"},{"location":"reference/bumpversion/vcs/#commit_1","text":"def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name )","title":"commit"},{"location":"reference/bumpversion/vcs/#is_usable_1","text":"def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise","title":"is_usable"},{"location":"reference/bumpversion/vcs/#latest_tag_info","text":"def latest_tag_info ( ) View Source @ classmethod def latest_tag_info ( cls ) : try : # git - describe doesn ' t update the git-index, so we do that subprocess . check_output ( [ \" git \" , \" update-index \" , \" --refresh \" ] ) # get info about the latest tag in git describe_out = ( subprocess . check_output ( [ \" git \" , \" describe \" , \" --dirty \" , \" --tags \" , \" --long \" , \" --abbrev=40 \" , \" --match=v* \" , ], stderr = subprocess . STDOUT , ) . decode () . split ( \" - \" ) ) except subprocess . CalledProcessError : logger . debug ( \" Error when running git describe \" ) return {} info = {} if describe_out [ - 1 ]. strip () == \" dirty \" : info [ \" dirty \" ] = True describe_out . pop () info [ \" commit_sha \" ] = describe_out . pop () . lstrip ( \" g \" ) info [ \" distance_to_latest_tag \" ] = int ( describe_out . pop ()) info [ \" current_version \" ] = \" - \" . join ( describe_out ) . lstrip ( \" v \" ) return info","title":"latest_tag_info"},{"location":"reference/bumpversion/vcs/#tag","text":"def tag ( sign , name , message ) Create a tag of the new_version in VCS. If only name is given, bumpversion uses a lightweight tag. Otherwise, it utilizes an annotated tag. View Source @ classmethod def tag ( cls , sign , name , message ) : \"\"\" Create a tag of the new_version in VCS . If only name is given , bumpversion uses a lightweight tag . Otherwise , it utilizes an annotated tag . \"\"\" command = [ \" git \" , \" tag \" , name ] if sign : command += [ \" --sign \" ] if message : command += [ \" --message \" , message ] subprocess . check_output ( command )","title":"tag"},{"location":"reference/bumpversion/vcs/#mercurial","text":"class Mercurial ( / , * args , ** kwargs ) View Source class Mercurial ( BaseVCS ) : _TEST_USABLE_COMMAND = [ \" hg \" , \" root \" ] _COMMIT_COMMAND = [ \" hg \" , \" commit \" , \" --logfile \" ] @ classmethod def latest_tag_info ( cls ) : return {} @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" hg \" , \" status \" , \" -mard \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Mercurial working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) ) @ classmethod def add_path ( cls , path ) : pass @ classmethod def tag ( cls , sign , name , message ) : command = [ \" hg \" , \" tag \" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \" Mercurial does not support signed tags. \" ) if message : command += [ \" --message \" , message ] subprocess . check_output ( command )","title":"Mercurial"},{"location":"reference/bumpversion/vcs/#ancestors-in-mro_1","text":"bumpversion.vcs.BaseVCS","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/vcs/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/bumpversion/vcs/#add_path_1","text":"def add_path ( path ) View Source @classmethod def add_path ( cls , path ) : pass","title":"add_path"},{"location":"reference/bumpversion/vcs/#assert_nondirty_1","text":"def assert_nondirty ( ) View Source @ classmethod def assert_nondirty ( cls ) : lines = [ line . strip () for line in subprocess . check_output ( [ \" hg \" , \" status \" , \" -mard \" ] ) . splitlines () if not line . strip () . startswith ( b \" ?? \" ) ] if lines : raise WorkingDirectoryIsDirtyException ( \" Mercurial working directory is not clean: \\n {} \" . format ( b \" \\n \" . join ( lines ) . decode () ) )","title":"assert_nondirty"},{"location":"reference/bumpversion/vcs/#commit_2","text":"def commit ( message , context , extra_args = None ) View Source @ classmethod def commit ( cls , message , context , extra_args = None ) : extra_args = extra_args or [] with NamedTemporaryFile ( \" wb \" , delete = False ) as f : f . write ( message . encode ( \" utf-8 \" )) env = os . environ . copy () env [ \" HGENCODING \" ] = \" utf-8 \" for key in ( \" current_version \" , \" new_version \" ) : env [ str ( \" BUMPVERSION_ \" + key . upper ()) ] = str ( context [ key ] ) try : subprocess . check_output ( cls . _COMMIT_COMMAND + [ f . name ] + extra_args , env = env ) except subprocess . CalledProcessError as exc : err_msg = \" Failed to run {}: return code {}, output: {} \" . format ( exc . cmd , exc . returncode , exc . output ) logger . exception ( err_msg ) raise exc finally : os . unlink ( f . name )","title":"commit"},{"location":"reference/bumpversion/vcs/#is_usable_2","text":"def is_usable ( ) View Source @ classmethod def is_usable ( cls ) : try : return ( subprocess . call ( cls . _TEST_USABLE_COMMAND , stderr = subprocess . PIPE , stdout = subprocess . PIPE , ) == 0 ) except OSError as e : if e . errno in ( errno . ENOENT , errno . EACCES ) : return False raise","title":"is_usable"},{"location":"reference/bumpversion/vcs/#latest_tag_info_1","text":"def latest_tag_info ( ) View Source @ classmethod def latest_tag_info ( cls ) : return {}","title":"latest_tag_info"},{"location":"reference/bumpversion/vcs/#tag_1","text":"def tag ( sign , name , message ) View Source @ classmethod def tag ( cls , sign , name , message ) : command = [ \" hg \" , \" tag \" , name ] if sign : raise MercurialDoesNotSupportSignedTagsException ( \" Mercurial does not support signed tags. \" ) if message : command += [ \" --message \" , message ] subprocess . check_output ( command )","title":"tag"},{"location":"reference/bumpversion/version_part/","text":"Module bumpversion.version_part View Source import logging import re import sre_constants import string from bumpversion.exceptions import ( MissingValueForSerializationException , IncompleteVersionRepresentationException , InvalidVersionPartException , ) from bumpversion.functions import NumericFunction , ValuesFunction from bumpversion.utils import keyvaluestring logger = logging . getLogger ( __name__ ) class PartConfiguration : function_cls = NumericFunction def __init__ ( self , * args , ** kwds ): self . function = self . function_cls ( * args , ** kwds ) @property def first_value ( self ): return str ( self . function . first_value ) @property def optional_value ( self ): return str ( self . function . optional_value ) def bump ( self , value = None ): return self . function . bump ( value ) class ConfiguredVersionPartConfiguration ( PartConfiguration ): function_cls = ValuesFunction class NumericVersionPartConfiguration ( PartConfiguration ): function_cls = NumericFunction class VersionPart : \"\"\" This class represents part of a version number. It contains a self.config object that rules how the part behaves when increased or reset. \"\"\" def __init__ ( self , value , config = None ): self . _value = value if config is None : config = NumericVersionPartConfiguration () self . config = config @property def value ( self ): return self . _value or self . config . optional_value def copy ( self ): return VersionPart ( self . _value ) def bump ( self ): return VersionPart ( self . config . bump ( self . value ), self . config ) def is_optional ( self ): return self . value == self . config . optional_value def __format__ ( self , format_spec ): return self . value def __repr__ ( self ): return \"<bumpversion.VersionPart:{}:{}>\" . format ( self . config . __class__ . __name__ , self . value ) def __eq__ ( self , other ): return self . value == other . value def null ( self ): return VersionPart ( self . config . first_value , self . config ) class Version : def __init__ ( self , values , original = None ): self . _values = dict ( values ) self . original = original def __getitem__ ( self , key ): return self . _values [ key ] def __len__ ( self ): return len ( self . _values ) def __iter__ ( self ): return iter ( self . _values ) def __repr__ ( self ): return \"<bumpversion.Version:{}>\" . format ( keyvaluestring ( self . _values )) def bump ( self , part_name , order ): bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ] . bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ] . null () else : new_values [ label ] = self . _values [ label ] . copy () if not bumped : raise InvalidVersionPartException ( \"No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version def labels_for_format ( serialize_format ): return ( label for _ , label , _ , _ in string . Formatter () . parse ( serialize_format ) if label ) class VersionConfig : \"\"\" Holds a complete representation of a version string \"\"\" def __init__ ( self , parse , serialize , search , replace , part_configs = None ): try : self . parse_regex = re . compile ( parse , re . VERBOSE ) except sre_constants . error as e : # TODO: use re.error here mayhaps logger . error ( \"--parse ' %s ' is not a valid regex\" , parse ) raise e self . serialize_formats = serialize if not part_configs : part_configs = {} self . part_configs = part_configs self . search = search self . replace = replace def order ( self ): # currently, order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ]) def parse ( self , version_string ): if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \"#\" )[ 0 ] . strip () for l in self . parse_regex . pattern . splitlines ()] ) logger . info ( \"Parsing version ' %s ' using regexp ' %s '\" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \"Evaluating 'parse' option: ' %s ' does not parse current version ' %s '\" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items (): _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \"Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v def _serialize ( self , version , serialize_format , context , raise_if_incomplete = False ): \"\"\" Attempts to serialize a version with the given serialization format. Raises MissingValueForSerializationException if not serializable \"\"\" values = context . copy () for k in version : values [ k ] = version [ k ] # TODO dump complete context on debug level try : # test whether all parts required in the format have values serialized = serialize_format . format ( ** values ) except KeyError as e : missing_key = getattr ( e , \"message\" , e . args [ 0 ]) raise MissingValueForSerializationException ( \"Did not find key {} in {} when serializing version number\" . format ( repr ( missing_key ), repr ( version ) ) ) keys_needing_representation = set () found_required = False for k in self . order (): v = values [ k ] if not isinstance ( v , VersionPart ): # values coming from environment variables don't need # representation continue if not v . is_optional (): found_required = True keys_needing_representation . add ( k ) elif not found_required : keys_needing_representation . add ( k ) required_by_format = set ( labels_for_format ( serialize_format )) # try whether all parsed keys are represented if raise_if_incomplete : if not keys_needing_representation <= required_by_format : raise IncompleteVersionRepresentationException ( \"Could not represent '{}' in format '{}'\" . format ( \"', '\" . join ( keys_needing_representation ^ required_by_format ), serialize_format , ) ) return serialized def _choose_serialize_format ( self , version , context ): chosen = None logger . debug ( \"Available serialization formats: ' %s '\" , \"', '\" . join ( self . serialize_formats )) for serialize_format in self . serialize_formats : try : self . _serialize ( version , serialize_format , context , raise_if_incomplete = True ) chosen = serialize_format logger . debug ( \"Found ' %s ' to be a usable serialization format\" , chosen ) except IncompleteVersionRepresentationException as e : if not chosen : chosen = serialize_format except MissingValueForSerializationException as e : logger . info ( e . message ) raise e if not chosen : raise KeyError ( \"Did not find suitable serialization format\" ) logger . debug ( \"Selected serialization format ' %s '\" , chosen ) return chosen def serialize ( self , version , context ): serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ), context ) logger . debug ( \"Serialized to ' %s '\" , serialized ) return serialized Variables logger Functions labels_for_format def labels_for_format ( serialize_format ) View Source def labels_for_format ( serialize_format ) : return ( label for _ , label , _ , _ in string . Formatter () . parse ( serialize_format ) if label ) Classes ConfiguredVersionPartConfiguration class ConfiguredVersionPartConfiguration ( * args , ** kwds ) View Source class ConfiguredVersionPartConfiguration ( PartConfiguration ): function_cls = ValuesFunction Ancestors (in MRO) bumpversion.version_part.PartConfiguration Class variables function_cls Instance variables first_value optional_value Methods bump def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value ) NumericVersionPartConfiguration class NumericVersionPartConfiguration ( * args , ** kwds ) View Source class NumericVersionPartConfiguration ( PartConfiguration ): function_cls = NumericFunction Ancestors (in MRO) bumpversion.version_part.PartConfiguration Class variables function_cls Instance variables first_value optional_value Methods bump def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value ) PartConfiguration class PartConfiguration ( * args , ** kwds ) View Source class PartConfiguration : function_cls = NumericFunction def __init__ ( self , * args , ** kwds ) : self . function = self . function_cls ( * args , ** kwds ) @ property def first_value ( self ) : return str ( self . function . first_value ) @ property def optional_value ( self ) : return str ( self . function . optional_value ) def bump ( self , value = None ) : return self . function . bump ( value ) Descendants bumpversion.version_part.ConfiguredVersionPartConfiguration bumpversion.version_part.NumericVersionPartConfiguration Class variables function_cls Instance variables first_value optional_value Methods bump def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value ) Version class Version ( values , original = None ) View Source class Version : def __init__ ( self , values , original = None ) : self . _values = dict ( values ) self . original = original def __getitem__ ( self , key ) : return self . _values [ key ] def __len__ ( self ) : return len ( self . _values ) def __iter__ ( self ) : return iter ( self . _values ) def __repr__ ( self ) : return \" <bumpversion.Version:{}> \" . format ( keyvaluestring ( self . _values )) def bump ( self , part_name , order ) : bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ]. bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ]. null () else : new_values [ label ] = self . _values [ label ]. copy () if not bumped : raise InvalidVersionPartException ( \" No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version Methods bump def bump ( self , part_name , order ) View Source def bump ( self , part_name , order ) : bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ]. bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ]. null () else : new_values [ label ] = self . _values [ label ]. copy () if not bumped : raise InvalidVersionPartException ( \" No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version VersionConfig class VersionConfig ( parse , serialize , search , replace , part_configs = None ) Holds a complete representation of a version string View Source class VersionConfig : \"\"\" Holds a complete representation of a version string \"\"\" def __init__ ( self , parse , serialize , search , replace , part_configs = None ) : try : self . parse_regex = re . compile ( parse , re . VERBOSE ) except sre_constants . error as e : # TODO : use re . error here mayhaps logger . error ( \" --parse '%s' is not a valid regex \" , parse ) raise e self . serialize_formats = serialize if not part_configs : part_configs = {} self . part_configs = part_configs self . search = search self . replace = replace def order ( self ) : # currently , order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ] ) def parse ( self , version_string ) : if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \" # \" ) [ 0 ]. strip () for l in self . parse_regex . pattern . splitlines () ] ) logger . info ( \" Parsing version '%s' using regexp '%s' \" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \" Evaluating 'parse' option: '%s' does not parse current version '%s' \" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items () : _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \" Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v def _serialize ( self , version , serialize_format , context , raise_if_incomplete = False ) : \"\"\" Attempts to serialize a version with the given serialization format . Raises MissingValueForSerializationException if not serializable \"\"\" values = context . copy () for k in version : values [ k ] = version [ k ] # TODO dump complete context on debug level try : # test whether all parts required in the format have values serialized = serialize_format . format ( ** values ) except KeyError as e : missing_key = getattr ( e , \" message \" , e . args [ 0 ] ) raise MissingValueForSerializationException ( \" Did not find key {} in {} when serializing version number \" . format ( repr ( missing_key ) , repr ( version ) ) ) keys_needing_representation = set () found_required = False for k in self . order () : v = values [ k ] if not isinstance ( v , VersionPart ) : # values coming from environment variables don ' t need # representation continue if not v . is_optional () : found_required = True keys_needing_representation . add ( k ) elif not found_required : keys_needing_representation . add ( k ) required_by_format = set ( labels_for_format ( serialize_format )) # try whether all parsed keys are represented if raise_if_incomplete : if not keys_needing_representation <= required_by_format : raise IncompleteVersionRepresentationException ( \" Could not represent '{}' in format '{}' \" . format ( \" ', ' \" . join ( keys_needing_representation ^ required_by_format ) , serialize_format , ) ) return serialized def _choose_serialize_format ( self , version , context ) : chosen = None logger . debug ( \" Available serialization formats: '%s' \" , \" ', ' \" . join ( self . serialize_formats )) for serialize_format in self . serialize_formats : try : self . _serialize ( version , serialize_format , context , raise_if_incomplete = True ) chosen = serialize_format logger . debug ( \" Found '%s' to be a usable serialization format \" , chosen ) except IncompleteVersionRepresentationException as e : if not chosen : chosen = serialize_format except MissingValueForSerializationException as e : logger . info ( e . message ) raise e if not chosen : raise KeyError ( \" Did not find suitable serialization format \" ) logger . debug ( \" Selected serialization format '%s' \" , chosen ) return chosen def serialize ( self , version , context ) : serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ) , context ) logger . debug ( \" Serialized to '%s' \" , serialized ) return serialized Methods order def order ( self ) View Source def order ( self ) : # currently , order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ] ) parse def parse ( self , version_string ) View Source def parse ( self , version_string ) : if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \" # \" ) [ 0 ]. strip () for l in self . parse_regex . pattern . splitlines () ] ) logger . info ( \" Parsing version '%s' using regexp '%s' \" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \" Evaluating 'parse' option: '%s' does not parse current version '%s' \" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items () : _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \" Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v serialize def serialize ( self , version , context ) View Source def serialize ( self , version , context ) : serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ) , context ) logger . debug ( \" Serialized to '%s' \" , serialized ) return serialized VersionPart class VersionPart ( value , config = None ) This class represents part of a version number. It contains a self.config object that rules how the part behaves when increased or reset. View Source class VersionPart : \"\"\" This class represents part of a version number . It contains a self . config object that rules how the part behaves when increased or reset . \"\"\" def __init__ ( self , value , config = None ) : self . _value = value if config is None : config = NumericVersionPartConfiguration () self . config = config @ property def value ( self ) : return self . _value or self . config . optional_value def copy ( self ) : return VersionPart ( self . _value ) def bump ( self ) : return VersionPart ( self . config . bump ( self . value ) , self . config ) def is_optional ( self ) : return self . value == self . config . optional_value def __format__ ( self , format_spec ) : return self . value def __repr__ ( self ) : return \" <bumpversion.VersionPart:{}:{}> \" . format ( self . config . __class__ . __name__ , self . value ) def __eq__ ( self , other ) : return self . value == other . value def null ( self ) : return VersionPart ( self . config . first_value , self . config ) Instance variables value Methods bump def bump ( self ) View Source def bump ( self ) : return VersionPart ( self . config . bump ( self . value ) , self . config ) copy def copy ( self ) View Source def copy ( self ) : return VersionPart ( self . _value ) is_optional def is_optional ( self ) View Source def is_optional ( self ) : return self . value == self . config . optional_value null def null ( self ) View Source def null ( self ) : return VersionPart ( self . config . first_value , self . config )","title":"Version Part"},{"location":"reference/bumpversion/version_part/#module-bumpversionversion_part","text":"View Source import logging import re import sre_constants import string from bumpversion.exceptions import ( MissingValueForSerializationException , IncompleteVersionRepresentationException , InvalidVersionPartException , ) from bumpversion.functions import NumericFunction , ValuesFunction from bumpversion.utils import keyvaluestring logger = logging . getLogger ( __name__ ) class PartConfiguration : function_cls = NumericFunction def __init__ ( self , * args , ** kwds ): self . function = self . function_cls ( * args , ** kwds ) @property def first_value ( self ): return str ( self . function . first_value ) @property def optional_value ( self ): return str ( self . function . optional_value ) def bump ( self , value = None ): return self . function . bump ( value ) class ConfiguredVersionPartConfiguration ( PartConfiguration ): function_cls = ValuesFunction class NumericVersionPartConfiguration ( PartConfiguration ): function_cls = NumericFunction class VersionPart : \"\"\" This class represents part of a version number. It contains a self.config object that rules how the part behaves when increased or reset. \"\"\" def __init__ ( self , value , config = None ): self . _value = value if config is None : config = NumericVersionPartConfiguration () self . config = config @property def value ( self ): return self . _value or self . config . optional_value def copy ( self ): return VersionPart ( self . _value ) def bump ( self ): return VersionPart ( self . config . bump ( self . value ), self . config ) def is_optional ( self ): return self . value == self . config . optional_value def __format__ ( self , format_spec ): return self . value def __repr__ ( self ): return \"<bumpversion.VersionPart:{}:{}>\" . format ( self . config . __class__ . __name__ , self . value ) def __eq__ ( self , other ): return self . value == other . value def null ( self ): return VersionPart ( self . config . first_value , self . config ) class Version : def __init__ ( self , values , original = None ): self . _values = dict ( values ) self . original = original def __getitem__ ( self , key ): return self . _values [ key ] def __len__ ( self ): return len ( self . _values ) def __iter__ ( self ): return iter ( self . _values ) def __repr__ ( self ): return \"<bumpversion.Version:{}>\" . format ( keyvaluestring ( self . _values )) def bump ( self , part_name , order ): bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ] . bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ] . null () else : new_values [ label ] = self . _values [ label ] . copy () if not bumped : raise InvalidVersionPartException ( \"No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version def labels_for_format ( serialize_format ): return ( label for _ , label , _ , _ in string . Formatter () . parse ( serialize_format ) if label ) class VersionConfig : \"\"\" Holds a complete representation of a version string \"\"\" def __init__ ( self , parse , serialize , search , replace , part_configs = None ): try : self . parse_regex = re . compile ( parse , re . VERBOSE ) except sre_constants . error as e : # TODO: use re.error here mayhaps logger . error ( \"--parse ' %s ' is not a valid regex\" , parse ) raise e self . serialize_formats = serialize if not part_configs : part_configs = {} self . part_configs = part_configs self . search = search self . replace = replace def order ( self ): # currently, order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ]) def parse ( self , version_string ): if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \"#\" )[ 0 ] . strip () for l in self . parse_regex . pattern . splitlines ()] ) logger . info ( \"Parsing version ' %s ' using regexp ' %s '\" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \"Evaluating 'parse' option: ' %s ' does not parse current version ' %s '\" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items (): _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \"Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v def _serialize ( self , version , serialize_format , context , raise_if_incomplete = False ): \"\"\" Attempts to serialize a version with the given serialization format. Raises MissingValueForSerializationException if not serializable \"\"\" values = context . copy () for k in version : values [ k ] = version [ k ] # TODO dump complete context on debug level try : # test whether all parts required in the format have values serialized = serialize_format . format ( ** values ) except KeyError as e : missing_key = getattr ( e , \"message\" , e . args [ 0 ]) raise MissingValueForSerializationException ( \"Did not find key {} in {} when serializing version number\" . format ( repr ( missing_key ), repr ( version ) ) ) keys_needing_representation = set () found_required = False for k in self . order (): v = values [ k ] if not isinstance ( v , VersionPart ): # values coming from environment variables don't need # representation continue if not v . is_optional (): found_required = True keys_needing_representation . add ( k ) elif not found_required : keys_needing_representation . add ( k ) required_by_format = set ( labels_for_format ( serialize_format )) # try whether all parsed keys are represented if raise_if_incomplete : if not keys_needing_representation <= required_by_format : raise IncompleteVersionRepresentationException ( \"Could not represent '{}' in format '{}'\" . format ( \"', '\" . join ( keys_needing_representation ^ required_by_format ), serialize_format , ) ) return serialized def _choose_serialize_format ( self , version , context ): chosen = None logger . debug ( \"Available serialization formats: ' %s '\" , \"', '\" . join ( self . serialize_formats )) for serialize_format in self . serialize_formats : try : self . _serialize ( version , serialize_format , context , raise_if_incomplete = True ) chosen = serialize_format logger . debug ( \"Found ' %s ' to be a usable serialization format\" , chosen ) except IncompleteVersionRepresentationException as e : if not chosen : chosen = serialize_format except MissingValueForSerializationException as e : logger . info ( e . message ) raise e if not chosen : raise KeyError ( \"Did not find suitable serialization format\" ) logger . debug ( \"Selected serialization format ' %s '\" , chosen ) return chosen def serialize ( self , version , context ): serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ), context ) logger . debug ( \"Serialized to ' %s '\" , serialized ) return serialized","title":"Module bumpversion.version_part"},{"location":"reference/bumpversion/version_part/#variables","text":"logger","title":"Variables"},{"location":"reference/bumpversion/version_part/#functions","text":"","title":"Functions"},{"location":"reference/bumpversion/version_part/#labels_for_format","text":"def labels_for_format ( serialize_format ) View Source def labels_for_format ( serialize_format ) : return ( label for _ , label , _ , _ in string . Formatter () . parse ( serialize_format ) if label )","title":"labels_for_format"},{"location":"reference/bumpversion/version_part/#classes","text":"","title":"Classes"},{"location":"reference/bumpversion/version_part/#configuredversionpartconfiguration","text":"class ConfiguredVersionPartConfiguration ( * args , ** kwds ) View Source class ConfiguredVersionPartConfiguration ( PartConfiguration ): function_cls = ValuesFunction","title":"ConfiguredVersionPartConfiguration"},{"location":"reference/bumpversion/version_part/#ancestors-in-mro","text":"bumpversion.version_part.PartConfiguration","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/version_part/#class-variables","text":"function_cls","title":"Class variables"},{"location":"reference/bumpversion/version_part/#instance-variables","text":"first_value optional_value","title":"Instance variables"},{"location":"reference/bumpversion/version_part/#methods","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#bump","text":"def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value )","title":"bump"},{"location":"reference/bumpversion/version_part/#numericversionpartconfiguration","text":"class NumericVersionPartConfiguration ( * args , ** kwds ) View Source class NumericVersionPartConfiguration ( PartConfiguration ): function_cls = NumericFunction","title":"NumericVersionPartConfiguration"},{"location":"reference/bumpversion/version_part/#ancestors-in-mro_1","text":"bumpversion.version_part.PartConfiguration","title":"Ancestors (in MRO)"},{"location":"reference/bumpversion/version_part/#class-variables_1","text":"function_cls","title":"Class variables"},{"location":"reference/bumpversion/version_part/#instance-variables_1","text":"first_value optional_value","title":"Instance variables"},{"location":"reference/bumpversion/version_part/#methods_1","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#bump_1","text":"def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value )","title":"bump"},{"location":"reference/bumpversion/version_part/#partconfiguration","text":"class PartConfiguration ( * args , ** kwds ) View Source class PartConfiguration : function_cls = NumericFunction def __init__ ( self , * args , ** kwds ) : self . function = self . function_cls ( * args , ** kwds ) @ property def first_value ( self ) : return str ( self . function . first_value ) @ property def optional_value ( self ) : return str ( self . function . optional_value ) def bump ( self , value = None ) : return self . function . bump ( value )","title":"PartConfiguration"},{"location":"reference/bumpversion/version_part/#descendants","text":"bumpversion.version_part.ConfiguredVersionPartConfiguration bumpversion.version_part.NumericVersionPartConfiguration","title":"Descendants"},{"location":"reference/bumpversion/version_part/#class-variables_2","text":"function_cls","title":"Class variables"},{"location":"reference/bumpversion/version_part/#instance-variables_2","text":"first_value optional_value","title":"Instance variables"},{"location":"reference/bumpversion/version_part/#methods_2","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#bump_2","text":"def bump ( self , value = None ) View Source def bump ( self , value = None ) : return self . function . bump ( value )","title":"bump"},{"location":"reference/bumpversion/version_part/#version","text":"class Version ( values , original = None ) View Source class Version : def __init__ ( self , values , original = None ) : self . _values = dict ( values ) self . original = original def __getitem__ ( self , key ) : return self . _values [ key ] def __len__ ( self ) : return len ( self . _values ) def __iter__ ( self ) : return iter ( self . _values ) def __repr__ ( self ) : return \" <bumpversion.Version:{}> \" . format ( keyvaluestring ( self . _values )) def bump ( self , part_name , order ) : bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ]. bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ]. null () else : new_values [ label ] = self . _values [ label ]. copy () if not bumped : raise InvalidVersionPartException ( \" No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version","title":"Version"},{"location":"reference/bumpversion/version_part/#methods_3","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#bump_3","text":"def bump ( self , part_name , order ) View Source def bump ( self , part_name , order ) : bumped = False new_values = {} for label in order : if label not in self . _values : continue if label == part_name : new_values [ label ] = self . _values [ label ]. bump () bumped = True elif bumped : new_values [ label ] = self . _values [ label ]. null () else : new_values [ label ] = self . _values [ label ]. copy () if not bumped : raise InvalidVersionPartException ( \" No part named %r \" % part_name ) new_version = Version ( new_values ) return new_version","title":"bump"},{"location":"reference/bumpversion/version_part/#versionconfig","text":"class VersionConfig ( parse , serialize , search , replace , part_configs = None ) Holds a complete representation of a version string View Source class VersionConfig : \"\"\" Holds a complete representation of a version string \"\"\" def __init__ ( self , parse , serialize , search , replace , part_configs = None ) : try : self . parse_regex = re . compile ( parse , re . VERBOSE ) except sre_constants . error as e : # TODO : use re . error here mayhaps logger . error ( \" --parse '%s' is not a valid regex \" , parse ) raise e self . serialize_formats = serialize if not part_configs : part_configs = {} self . part_configs = part_configs self . search = search self . replace = replace def order ( self ) : # currently , order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ] ) def parse ( self , version_string ) : if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \" # \" ) [ 0 ]. strip () for l in self . parse_regex . pattern . splitlines () ] ) logger . info ( \" Parsing version '%s' using regexp '%s' \" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \" Evaluating 'parse' option: '%s' does not parse current version '%s' \" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items () : _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \" Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v def _serialize ( self , version , serialize_format , context , raise_if_incomplete = False ) : \"\"\" Attempts to serialize a version with the given serialization format . Raises MissingValueForSerializationException if not serializable \"\"\" values = context . copy () for k in version : values [ k ] = version [ k ] # TODO dump complete context on debug level try : # test whether all parts required in the format have values serialized = serialize_format . format ( ** values ) except KeyError as e : missing_key = getattr ( e , \" message \" , e . args [ 0 ] ) raise MissingValueForSerializationException ( \" Did not find key {} in {} when serializing version number \" . format ( repr ( missing_key ) , repr ( version ) ) ) keys_needing_representation = set () found_required = False for k in self . order () : v = values [ k ] if not isinstance ( v , VersionPart ) : # values coming from environment variables don ' t need # representation continue if not v . is_optional () : found_required = True keys_needing_representation . add ( k ) elif not found_required : keys_needing_representation . add ( k ) required_by_format = set ( labels_for_format ( serialize_format )) # try whether all parsed keys are represented if raise_if_incomplete : if not keys_needing_representation <= required_by_format : raise IncompleteVersionRepresentationException ( \" Could not represent '{}' in format '{}' \" . format ( \" ', ' \" . join ( keys_needing_representation ^ required_by_format ) , serialize_format , ) ) return serialized def _choose_serialize_format ( self , version , context ) : chosen = None logger . debug ( \" Available serialization formats: '%s' \" , \" ', ' \" . join ( self . serialize_formats )) for serialize_format in self . serialize_formats : try : self . _serialize ( version , serialize_format , context , raise_if_incomplete = True ) chosen = serialize_format logger . debug ( \" Found '%s' to be a usable serialization format \" , chosen ) except IncompleteVersionRepresentationException as e : if not chosen : chosen = serialize_format except MissingValueForSerializationException as e : logger . info ( e . message ) raise e if not chosen : raise KeyError ( \" Did not find suitable serialization format \" ) logger . debug ( \" Selected serialization format '%s' \" , chosen ) return chosen def serialize ( self , version , context ) : serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ) , context ) logger . debug ( \" Serialized to '%s' \" , serialized ) return serialized","title":"VersionConfig"},{"location":"reference/bumpversion/version_part/#methods_4","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#order","text":"def order ( self ) View Source def order ( self ) : # currently , order depends on the first given serialization format # this seems like a good idea because this should be the most complete format return labels_for_format ( self . serialize_formats [ 0 ] )","title":"order"},{"location":"reference/bumpversion/version_part/#parse","text":"def parse ( self , version_string ) View Source def parse ( self , version_string ) : if not version_string : return None regexp_one_line = \"\" . join ( [ l . split ( \" # \" ) [ 0 ]. strip () for l in self . parse_regex . pattern . splitlines () ] ) logger . info ( \" Parsing version '%s' using regexp '%s' \" , version_string , regexp_one_line , ) match = self . parse_regex . search ( version_string ) _parsed = {} if not match : logger . warning ( \" Evaluating 'parse' option: '%s' does not parse current version '%s' \" , self . parse_regex . pattern , version_string , ) return None for key , value in match . groupdict () . items () : _parsed [ key ] = VersionPart ( value , self . part_configs . get ( key )) v = Version ( _parsed , version_string ) logger . info ( \" Parsed the following values: %s \" , keyvaluestring ( v . _values )) return v","title":"parse"},{"location":"reference/bumpversion/version_part/#serialize","text":"def serialize ( self , version , context ) View Source def serialize ( self , version , context ) : serialized = self . _serialize ( version , self . _choose_serialize_format ( version , context ) , context ) logger . debug ( \" Serialized to '%s' \" , serialized ) return serialized","title":"serialize"},{"location":"reference/bumpversion/version_part/#versionpart","text":"class VersionPart ( value , config = None ) This class represents part of a version number. It contains a self.config object that rules how the part behaves when increased or reset. View Source class VersionPart : \"\"\" This class represents part of a version number . It contains a self . config object that rules how the part behaves when increased or reset . \"\"\" def __init__ ( self , value , config = None ) : self . _value = value if config is None : config = NumericVersionPartConfiguration () self . config = config @ property def value ( self ) : return self . _value or self . config . optional_value def copy ( self ) : return VersionPart ( self . _value ) def bump ( self ) : return VersionPart ( self . config . bump ( self . value ) , self . config ) def is_optional ( self ) : return self . value == self . config . optional_value def __format__ ( self , format_spec ) : return self . value def __repr__ ( self ) : return \" <bumpversion.VersionPart:{}:{}> \" . format ( self . config . __class__ . __name__ , self . value ) def __eq__ ( self , other ) : return self . value == other . value def null ( self ) : return VersionPart ( self . config . first_value , self . config )","title":"VersionPart"},{"location":"reference/bumpversion/version_part/#instance-variables_3","text":"value","title":"Instance variables"},{"location":"reference/bumpversion/version_part/#methods_5","text":"","title":"Methods"},{"location":"reference/bumpversion/version_part/#bump_4","text":"def bump ( self ) View Source def bump ( self ) : return VersionPart ( self . config . bump ( self . value ) , self . config )","title":"bump"},{"location":"reference/bumpversion/version_part/#copy","text":"def copy ( self ) View Source def copy ( self ) : return VersionPart ( self . _value )","title":"copy"},{"location":"reference/bumpversion/version_part/#is_optional","text":"def is_optional ( self ) View Source def is_optional ( self ) : return self . value == self . config . optional_value","title":"is_optional"},{"location":"reference/bumpversion/version_part/#null","text":"def null ( self ) View Source def null ( self ) : return VersionPart ( self . config . first_value , self . config )","title":"null"}]}